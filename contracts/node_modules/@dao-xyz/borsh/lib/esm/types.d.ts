import { BinaryReader, BinaryWriter } from "./binary.js";
/**
 * Class with constructor
 */
export type Constructor<T> = new (...args: any[]) => T;
export type AbstractType<T> = Function & {
    prototype: T;
};
export declare const extendingClasses: (clazz: any) => any[];
/**
 * @param clazz
 * @returns extendingClasses(clazz).length
 */
export declare const getOffset: (clazz: any) => number;
export interface OverrideType<T> {
    serialize: (arg: T, writer: BinaryWriter) => void;
    deserialize: (reader: BinaryReader) => T;
}
export type SmallIntegerType = "u8" | "u16" | "u32";
export type IntegerType = SmallIntegerType | "u64" | "u128" | "u256" | "u512";
export type FloatType = "f32" | "f64";
export type PrimitiveType = "bool" | "string" | IntegerType | FloatType;
export type FieldType = PrimitiveType | Constructor<any> | AbstractType<any> | CustomField<any> | WrappedType | Uint8Array | StringType;
export type SimpleField = {
    type: FieldType;
    index?: number;
};
export interface CustomField<T> extends OverrideType<T> {
    index?: number;
}
export declare class WrappedType {
    elementType: FieldType;
    constructor(elementType: FieldType);
    getDependency(): Constructor<any> | AbstractType<any> | undefined;
}
export declare class StringType {
    sizeEncoding: SmallIntegerType;
    constructor(sizeEncoding: SmallIntegerType);
}
export declare const string: (sizeEncoding: SmallIntegerType) => StringType;
export declare class OptionKind extends WrappedType {
}
export declare const option: (type: FieldType) => OptionKind;
export declare class VecKind extends WrappedType {
    sizeEncoding: SmallIntegerType;
    constructor(elementType: FieldType, sizeEncoding: SmallIntegerType);
}
export declare const vec: (type: FieldType, sizeEncoding?: SmallIntegerType) => VecKind;
export declare class FixedArrayKind extends WrappedType {
    length: number;
    constructor(type: FieldType, length: number);
}
export declare const fixedArray: (type: FieldType, length: number) => FixedArrayKind;
export interface Field {
    key: string;
    type: FieldType;
}
export declare class StructKind {
    variant?: number | number[] | string;
    serializer?: (any: any, writer: BinaryWriter, serialize: (obj: any) => Uint8Array) => void;
    fields: Field[];
    constructor(properties?: {
        variant?: number | number[] | string;
        fields: Field[];
    });
    getDependencies(): (Constructor<any> | AbstractType<any>)[];
}
export interface FieldMetaData {
    alias: string;
    type: string;
}
