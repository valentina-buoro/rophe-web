import { BorshError } from "./error.js";
export const extendingClasses = (clazz) => {
    let ret = [];
    if (clazz instanceof Function) {
        let baseClass = clazz;
        while (baseClass) {
            const newBaseClass = Object.getPrototypeOf(baseClass);
            if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {
                ret.push(newBaseClass);
                baseClass = newBaseClass;
            }
            else {
                return ret;
            }
        }
    }
    return ret;
};
/**
 * @param clazz
 * @returns extendingClasses(clazz).length
 */
export const getOffset = (clazz) => extendingClasses(clazz).length;
export class WrappedType {
    constructor(elementType) {
        this.elementType = elementType;
    }
    getDependency() {
        if (typeof this.elementType === "function")
            return this.elementType;
        if (this.elementType instanceof WrappedType)
            return this.elementType.getDependency(); // Recursive
        return undefined;
    }
}
export class StringType {
    constructor(sizeEncoding) {
        this.sizeEncoding = sizeEncoding;
    }
}
export const string = (sizeEncoding) => {
    return new StringType(sizeEncoding);
};
export class OptionKind extends WrappedType {
}
export const option = (type) => {
    return new OptionKind(type);
};
export class VecKind extends WrappedType {
    constructor(elementType, sizeEncoding) {
        super(elementType);
        this.sizeEncoding = sizeEncoding;
    }
}
export const vec = (type, sizeEncoding = "u32") => {
    return new VecKind(type, sizeEncoding);
};
export class FixedArrayKind extends WrappedType {
    constructor(type, length) {
        super(type);
        this.length = length;
    }
}
export const fixedArray = (type, length) => {
    return new FixedArrayKind(type, length);
};
export class StructKind {
    constructor(properties) {
        if (properties) {
            this.fields = properties.fields;
            this.variant = properties.variant;
        }
        else {
            this.fields = [];
        }
    }
    getDependencies() {
        let ret = [];
        this.fields.forEach((field, ix) => {
            if (!field) {
                throw new BorshError("Field: " + ix + " is missing specification");
            }
            if (field.type instanceof WrappedType) {
                let dependency = field.type.getDependency();
                if (dependency)
                    ret.push(dependency);
            }
            else if (typeof field.type === "function") {
                ret.push(field.type);
            }
        });
        return ret;
    }
}
//# sourceMappingURL=types.js.map