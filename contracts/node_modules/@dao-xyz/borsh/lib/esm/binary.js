import { readDoubleLE, readFloatLE, writeDoubleLE, writeFloatLE, } from "@protobufjs/float";
import utf8 from "@protobufjs/utf8";
import { checkInt, readBigUInt64LE, readUInt16LE, readUInt32LE, readUIntLE, toBigIntLE, writeBigUint64Le, writeBufferLEBigInt, writeUInt16LE, writeUInt32LE, } from "./bigint.js";
import { BorshError } from "./error.js";
const allocUnsafeFn = () => {
    if (globalThis.Buffer) {
        return globalThis.Buffer.allocUnsafe;
    }
    return (len) => new Uint8Array(len);
};
const allocUnsafe = allocUnsafeFn();
const writeStringBufferFnFn = () => {
    if (globalThis.Buffer) {
        return (length) => {
            if (length < 48)
                return utf8.write;
            return (string, buf, offset) => buf.write(string, offset);
        };
    }
    return () => utf8.write;
};
const writeStringBufferFn = writeStringBufferFnFn();
const stringLengthFn = () => {
    if (globalThis.Buffer) {
        return globalThis.Buffer.byteLength;
    }
    return utf8.length;
};
export class BinaryWriter {
    constructor() {
        this.totalSize = 0;
        this._writes = () => (this._buf = allocUnsafe(this.totalSize));
        this._writesTail = this._writes;
    }
    bool(value) {
        return BinaryWriter.bool(value, this);
    }
    static bool(value, writer) {
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => (writer._buf[offset] = value ? 1 : 0);
        writer.totalSize += 1;
    }
    u8(value) {
        return BinaryWriter.u8(value, this);
    }
    static u8(value, writer) {
        checkInt(value, 0, 0xff, 1);
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => (writer._buf[offset] = value);
        writer.totalSize += 1;
    }
    u16(value) {
        return BinaryWriter.u16(value, this);
    }
    static u16(value, writer) {
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => writeUInt16LE(value, writer._buf, offset);
        writer.totalSize += 2;
    }
    u32(value) {
        return BinaryWriter.u32(value, this);
    }
    static u32(value, writer) {
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => writeUInt32LE(value, writer._buf, offset);
        writer.totalSize += 4;
    }
    u64(value) {
        return BinaryWriter.u64(value, this);
    }
    static u64(value, writer) {
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => writeBigUint64Le(value, writer._buf, offset);
        writer.totalSize += 8;
    }
    u128(value) {
        return BinaryWriter.u128(value, this);
    }
    static u128(value, writer) {
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => writeBufferLEBigInt(value, 16, writer._buf, offset);
        writer.totalSize += 16;
    }
    u256(value) {
        return BinaryWriter.u256(value, this);
    }
    static u256(value, writer) {
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => writeBufferLEBigInt(value, 32, writer._buf, offset);
        writer.totalSize += 32;
    }
    u512(value) {
        return BinaryWriter.u512(value, this);
    }
    static u512(value, writer) {
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => writeBufferLEBigInt(value, 64, writer._buf, offset);
        writer.totalSize += 64;
    }
    f32(value) {
        return BinaryWriter.f32(value, this);
    }
    static f32(value, writer) {
        if (Number.isNaN(value)) {
            throw new BorshError("NaN is not supported for f32");
        }
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => writeFloatLE(value, writer._buf, offset);
        writer.totalSize += 4;
    }
    f64(value) {
        return BinaryWriter.f64(value, this);
    }
    static f64(value, writer) {
        if (Number.isNaN(value)) {
            throw new BorshError("NaN is not supported for f64");
        }
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => writeDoubleLE(value, writer._buf, offset);
        writer.totalSize += 8;
    }
    string(str) {
        return BinaryWriter.string(str, this);
    }
    static string(str, writer) {
        const len = stringLengthFn()(str);
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => {
            writeUInt32LE(len, writer._buf, offset);
            writeStringBufferFn(len)(str, writer._buf, offset + 4);
        };
        writer.totalSize += 4 + len;
    }
    static stringCustom(str, writer, lengthWriter = writeUInt32LE, lengthSize = 4) {
        const len = utf8.length(str);
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => {
            lengthWriter(len, writer._buf, offset);
            writeStringBufferFn(len)(str, writer._buf, offset + lengthSize);
        };
        writer.totalSize += lengthSize + len;
    }
    set(array) {
        let offset = this.totalSize;
        this._writes = this._writes.next = () => {
            this._buf.set(array, offset);
        };
        this.totalSize += array.length;
    }
    uint8Array(array) {
        return BinaryWriter.uint8Array(array, this);
    }
    static uint8Array(array, writer) {
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => {
            writeUInt32LE(array.length, writer._buf, offset);
            writer._buf.set(array, offset + 4);
        };
        writer.totalSize += array.length + 4;
    }
    static uint8ArrayCustom(array, writer, lengthWriter = writeUInt32LE, lengthSize = 4) {
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => {
            lengthWriter(array.length, writer._buf, offset);
            writer._buf.set(array, offset + lengthSize);
        };
        writer.totalSize += array.length + lengthSize;
    }
    static uint8ArrayFixed(array, writer) {
        let offset = writer.totalSize;
        writer._writes = writer._writes.next = () => {
            writer._buf.set(array, offset);
        };
        writer.totalSize += array.length;
    }
    static smallNumberEncoding(encoding) {
        if (encoding === "u8") {
            return [
                (value, buf, offset) => (buf[offset] = value),
                1,
            ];
        }
        else if (encoding === "u16") {
            return [writeUInt16LE, 2];
        }
        else if (encoding === "u32") {
            return [writeUInt32LE, 4];
        }
        else {
            throw new Error("Unsupported encoding: " + encoding);
        }
    }
    static write(encoding) {
        if (encoding === "u8") {
            return BinaryWriter.u8;
        }
        else if (encoding === "u16") {
            return BinaryWriter.u16;
        }
        else if (encoding === "u32") {
            return BinaryWriter.u32;
        }
        else if (encoding === "u64") {
            return BinaryWriter.u64;
        }
        else if (encoding === "u128") {
            return BinaryWriter.u128;
        }
        else if (encoding === "u256") {
            return BinaryWriter.u256;
        }
        else if (encoding === "u512") {
            return BinaryWriter.u512;
        }
        else if (encoding === "bool") {
            return BinaryWriter.bool;
        }
        else if (encoding === "f32") {
            return BinaryWriter.f32;
        }
        else if (encoding === "f64") {
            return BinaryWriter.f64;
        }
        else if (encoding === "string") {
            return BinaryWriter.string;
        }
        else {
            throw new Error("Unsupported encoding: " + encoding);
        }
    }
    finalize() {
        let current = this._writesTail;
        while (current != null) {
            current();
            current = current.next;
        }
        return this._buf;
    }
}
export class BinaryReader {
    constructor(buf) {
        this._buf = buf;
        this._offset = 0;
    }
    bool() {
        return BinaryReader.bool(this);
    }
    static bool(reader) {
        const value = reader._buf[reader._offset];
        reader._offset += 1;
        if (value !== 1 && value !== 0) {
            throw new BorshError("Unexpected value for boolean: " + value + ". Expecting either 1 or 0 ");
        }
        return value ? true : false;
    }
    u8() {
        return BinaryReader.u8(this);
    }
    static u8(reader) {
        if (reader._offset >= reader._buf.length) {
            throw new BorshError("Reader out of bounds");
        }
        const value = reader._buf[reader._offset];
        reader._offset += 1;
        return value;
    }
    u16() {
        return BinaryReader.u16(this);
    }
    static u16(reader) {
        const value = readUInt16LE(reader._buf, reader._offset);
        reader._offset += 2;
        return value;
    }
    u32() {
        return BinaryReader.u32(this);
    }
    static u32(reader) {
        const value = readUInt32LE(reader._buf, reader._offset);
        reader._offset += 4;
        return value;
    }
    u64() {
        return BinaryReader.u64(this);
    }
    static u64(reader) {
        const value = readBigUInt64LE(reader._buf, reader._offset);
        reader._offset += 8;
        return value;
    }
    u128() {
        return BinaryReader.u128(this);
    }
    static u128(reader) {
        const value = readUIntLE(reader._buf, reader._offset, 16);
        reader._offset += 16;
        return value;
    }
    u256() {
        return BinaryReader.u256(this);
    }
    static u256(reader) {
        const value = readUIntLE(reader._buf, reader._offset, 32);
        reader._offset += 32;
        return value;
    }
    u512() {
        return BinaryReader.u512(this);
    }
    static u512(reader) {
        const buf = reader.buffer(64);
        return toBigIntLE(buf);
    }
    f32() {
        return BinaryReader.f32(this);
    }
    static f32(reader) {
        const value = readFloatLE(reader._buf, reader._offset);
        reader._offset += 4;
        if (Number.isNaN(value)) {
            throw new BorshError("Recieved NaN reading f32");
        }
        return value;
    }
    f64() {
        return BinaryReader.f64(this);
    }
    static f64(reader) {
        const value = readDoubleLE(reader._buf, reader._offset);
        reader._offset += 8;
        if (Number.isNaN(value)) {
            throw new BorshError("Recieved NaN reading f64");
        }
        return value;
    }
    string() {
        return BinaryReader.string(this);
    }
    static string(reader) {
        const len = reader.u32();
        const end = reader._offset + len;
        if (end > reader._buf.length) {
            throw new BorshError("Error decoding UTF-8 string: Invalid length");
        }
        try {
            const string = utf8.read(reader._buf, reader._offset, end);
            reader._offset = end;
            return string;
        }
        catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
        }
    }
    static bufferString(reader) {
        const len = reader.u32();
        const end = reader._offset + len;
        if (end > reader._buf.length) {
            throw new BorshError("Error decoding UTF-8 string: Invalid length");
        }
        const string = reader._buf.toString(undefined, reader._offset, end);
        reader._offset = end;
        return string;
    }
    static bufferStringCustom(reader, length) {
        const len = length(reader);
        const end = reader._offset + len;
        if (end > reader._buf.length) {
            throw new BorshError("Error decoding UTF-8 string: Invalid length");
        }
        try {
            const string = reader._buf.toString(undefined, reader._offset, end);
            reader._offset = end;
            return string;
        }
        catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
        }
    }
    static stringCustom(reader, length) {
        const len = length(reader);
        const end = reader._offset + len;
        if (end > reader._buf.length) {
            throw new BorshError("Error decoding UTF-8 string: Invalid length");
        }
        try {
            const string = utf8.read(reader._buf, reader._offset, end);
            reader._offset = end;
            return string;
        }
        catch (e) {
            throw new BorshError(`Error decoding UTF-8 string: ${e}`);
        }
    }
    static read(encoding, fromBuffer) {
        if (encoding === "u8") {
            return BinaryReader.u8;
        }
        else if (encoding === "u16") {
            return BinaryReader.u16;
        }
        else if (encoding === "u32") {
            return BinaryReader.u32;
        }
        else if (encoding === "u64") {
            return BinaryReader.u64;
        }
        else if (encoding === "u128") {
            return BinaryReader.u128;
        }
        else if (encoding === "u256") {
            return BinaryReader.u256;
        }
        else if (encoding === "u512") {
            return BinaryReader.u512;
        }
        else if (encoding === "string") {
            return fromBuffer ? BinaryReader.bufferString : BinaryReader.string;
        }
        else if (encoding === "bool") {
            return BinaryReader.bool;
        }
        else if (encoding === "f32") {
            return BinaryReader.f32;
        }
        else if (encoding === "f64") {
            return BinaryReader.f64;
        }
        else {
            throw new Error("Unsupported encoding: " + encoding);
        }
    }
    buffer(len) {
        const end = this._offset + len;
        const result = this._buf.subarray(this._offset, end);
        this._offset = end;
        return result;
    }
    uint8Array() {
        return BinaryReader.uint8Array(this);
    }
    static uint8Array(reader, size = reader.u32()) {
        return reader.buffer(size);
    }
    readArray(fn) {
        const len = this.u32();
        const result = new Array(len);
        for (let i = 0; i < len; ++i) {
            result[i] = fn();
        }
        return result;
    }
}
//# sourceMappingURL=binary.js.map