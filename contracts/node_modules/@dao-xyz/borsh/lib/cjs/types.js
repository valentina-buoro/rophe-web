"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructKind = exports.fixedArray = exports.FixedArrayKind = exports.vec = exports.VecKind = exports.option = exports.OptionKind = exports.string = exports.StringType = exports.WrappedType = exports.getOffset = exports.extendingClasses = void 0;
const error_js_1 = require("./error.js");
const extendingClasses = (clazz) => {
    let ret = [];
    if (clazz instanceof Function) {
        let baseClass = clazz;
        while (baseClass) {
            const newBaseClass = Object.getPrototypeOf(baseClass);
            if (newBaseClass && newBaseClass !== Object && newBaseClass.name) {
                ret.push(newBaseClass);
                baseClass = newBaseClass;
            }
            else {
                return ret;
            }
        }
    }
    return ret;
};
exports.extendingClasses = extendingClasses;
/**
 * @param clazz
 * @returns extendingClasses(clazz).length
 */
const getOffset = (clazz) => (0, exports.extendingClasses)(clazz).length;
exports.getOffset = getOffset;
class WrappedType {
    constructor(elementType) {
        this.elementType = elementType;
    }
    getDependency() {
        if (typeof this.elementType === "function")
            return this.elementType;
        if (this.elementType instanceof WrappedType)
            return this.elementType.getDependency(); // Recursive
        return undefined;
    }
}
exports.WrappedType = WrappedType;
class StringType {
    constructor(sizeEncoding) {
        this.sizeEncoding = sizeEncoding;
    }
}
exports.StringType = StringType;
const string = (sizeEncoding) => {
    return new StringType(sizeEncoding);
};
exports.string = string;
class OptionKind extends WrappedType {
}
exports.OptionKind = OptionKind;
const option = (type) => {
    return new OptionKind(type);
};
exports.option = option;
class VecKind extends WrappedType {
    constructor(elementType, sizeEncoding) {
        super(elementType);
        this.sizeEncoding = sizeEncoding;
    }
}
exports.VecKind = VecKind;
const vec = (type, sizeEncoding = "u32") => {
    return new VecKind(type, sizeEncoding);
};
exports.vec = vec;
class FixedArrayKind extends WrappedType {
    constructor(type, length) {
        super(type);
        this.length = length;
    }
}
exports.FixedArrayKind = FixedArrayKind;
const fixedArray = (type, length) => {
    return new FixedArrayKind(type, length);
};
exports.fixedArray = fixedArray;
class StructKind {
    constructor(properties) {
        if (properties) {
            this.fields = properties.fields;
            this.variant = properties.variant;
        }
        else {
            this.fields = [];
        }
    }
    getDependencies() {
        let ret = [];
        this.fields.forEach((field, ix) => {
            if (!field) {
                throw new error_js_1.BorshError("Field: " + ix + " is missing specification");
            }
            if (field.type instanceof WrappedType) {
                let dependency = field.type.getDependency();
                if (dependency)
                    ret.push(dependency);
            }
            else if (typeof field.type === "function") {
                ret.push(field.type);
            }
        });
        return ret;
    }
}
exports.StructKind = StructKind;
//# sourceMappingURL=types.js.map