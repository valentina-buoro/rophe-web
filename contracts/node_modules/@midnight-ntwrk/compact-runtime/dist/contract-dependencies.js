"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.contractDependencies = void 0;
const runtime_1 = require("./runtime");
const utils_1 = require("./utils");
/**
 * Tests whether the input value is a {@link CompactVector}.
 *
 * @param x The value that is tested to be a {@link CompactVector}.
 */
function isCompactVector(x) {
    return Array.isArray(x) && x.every((element) => isCompactValue(element));
}
/**
 * Tests whether the input value is a {@link CompactStruct}.
 *
 * @param x The value that is tested to be a {@link CompactStruct}.
 */
function isCompactStruct(x) {
    return (typeof x === 'object' &&
        x !== null &&
        x !== undefined &&
        Object.entries(x).every(([key, value]) => typeof key === 'string' && isCompactValue(value)));
}
/**
 * Tests whether the input value is a {@link CompactValue}.
 *
 * @param x The value that is tested to be a {@link CompactValue}.
 */
function isCompactValue(x) {
    return (0, utils_1.isContractAddress)(x) || isCompactVector(x) || isCompactStruct(x);
}
const expectedValueError = (expected, actual) => {
    throw new runtime_1.CompactError(`Expected ${expected} but received ${JSON.stringify(actual)}`);
};
/**
 * Throws an error if the input value is not a {@link ContractAddress}, i.e., string.
 *
 * @param value The value that is asserted to be a {@link ContractAddress}.
 */
function assertIsContractAddress(value) {
    if (!(0, utils_1.isContractAddress)(value)) {
        expectedValueError('contract address', value);
    }
}
/**
 * Throws an error if the input value is not a {@link CompactVector}.
 *
 * @param value The value that is asserted to be a {@link CompactVector}.
 */
function assertIsCompactVector(value) {
    if (!isCompactVector(value)) {
        expectedValueError('vector', value);
    }
}
/**
 * Throws an error if the input value is not a {@link CompactStruct}.
 *
 * @param value The value that is asserted to be a {@link CompactStruct}.
 */
function assertIsCompactStruct(value) {
    if (!isCompactStruct(value)) {
        expectedValueError('struct', value);
    }
}
/**
 * Throws an error if the input value is not a {@link CompactValue}.
 *
 * @param x The value that is asserted to be a {@link CompactValue}.
 */
function assertIsCompactValue(x) {
    if (!isCompactValue(x)) {
        expectedValueError('Compact value', x);
    }
}
/**
 * Converts an unknown TypeScript value into a {@link CompactValue}. This conversion __should__ always succeed.
 *
 * @param x The value to convert.
 */
function toCompactValue(x) {
    assertIsCompactValue(x);
    return x;
}
/**
 * Extracts the contract addresses present in the given {@link CompactValue}.
 *
 * @param sparseCompactType A data structure indicating the locations of all contract references in the given {@link CompactValue}.
 * @param compactValue The Compact value containing contract references.
 * @param dependencies The current set of contract addresses extracted from the input ledger state.
 */
const compactValueDependencies = (sparseCompactType, compactValue, dependencies) => {
    if (sparseCompactType.tag == 'contractAddress') {
        assertIsContractAddress(compactValue);
        dependencies.add(compactValue);
    }
    else if (sparseCompactType.tag == 'struct') {
        assertIsCompactStruct(compactValue);
        Object.keys(compactValue).forEach((structElementId) => compactValueDependencies(sparseCompactType.elements[structElementId], compactValue[structElementId], dependencies));
    }
    else {
        assertIsCompactVector(compactValue);
        compactValue.forEach((vectorElement) => compactValueDependencies(sparseCompactType.sparseType, vectorElement, dependencies));
    }
};
/**
 * Converts a Compact value in the on-chain runtime representation ({@link AlignedValue}) into a TypeScript ({@link CompactValue})
 * representation.
 *
 * @param descriptor The descriptor to convert a {@link AlignedValue} into a TypeScript value.
 * @param value The value to convert.
 */
const alignedValueToCompactValue = (descriptor, { value }) => toCompactValue(descriptor.fromValue(value));
/**
 * Converts a {@link StateValue} into a {@link CompactValue} by treating the state as a `Cell` ADT containing a Compact value.
 *
 * @param descriptor The descriptor used to convert the {@link AlignedValue} extracted from the `Cell` ADT into a TypeScript
 *                   representation of a Compact value containing a contract address.
 * @param stateValue Represents a `Cell` ADT.
 */
const stateValueToCompactValue = (descriptor, stateValue) => alignedValueToCompactValue(descriptor, stateValue.asCell());
/**
 * Extracts the contract references contained in a Compact `Cell` ADT represented by the given {@link StateValue}.
 *
 * @param sparseCompactCellADT A data structure pointing to contract references in the Compact `Cell` ADT corresponding
 *                             to the given `state` parameter, if any exist.
 * @param state A portion of the input ledger state representing a Compact `Cell` ADT.
 * @param dependencies The current set of contract addresses extracted from the input ledger state.
 */
const compactCellDependencies = (sparseCompactCellADT, state, dependencies) => {
    const { sparseType, descriptor } = sparseCompactCellADT.valueType;
    compactValueDependencies(sparseType, stateValueToCompactValue(descriptor, state), dependencies);
};
/**
 * Extracts the contract references contained in a Compact `List` or `Set` ADT represented by the given {@link StateValue} array.
 *
 * @param sparseCompactArrayLikeADT A data structure pointing to contract references in the Compact `List` or `Set` ADT corresponding
 *                                  to the given `states` parameter, if any exist.
 * @param states A portion of the input ledger state representing a Compact `List` or `Set` ADT.
 * @param dependencies The current set of contract addresses extracted from the input ledger state.
 */
const compactArrayLikeADTDependencies = (sparseCompactArrayLikeADT, states, dependencies) => {
    const { sparseType, descriptor } = sparseCompactArrayLikeADT.valueType;
    states.forEach((state) => compactValueDependencies(sparseType, stateValueToCompactValue(descriptor, state), dependencies));
};
/**
 * Extracts the contract references contained in a Compact `Map` ADT represented by the given {@link StateMap} object.
 *
 * @param sparseCompactMapADT A data structure pointing to contract references in the Compact `Map` ADT corresponding
 *                            to the given `stateMap` parameter, if any exist.
 * @param stateMap A portion of the input ledger state representing a Compact `Map` ADT.
 * @param dependencies The current set of contract addresses extracted from the input ledger state.
 */
const compactMapADTDependencies = (sparseCompactMapADT, stateMap, dependencies) => {
    const { keyType, valueType } = sparseCompactMapADT;
    stateMap.keys().forEach((key) => {
        if (keyType) {
            compactValueDependencies(keyType.sparseType, alignedValueToCompactValue(keyType.descriptor, key), dependencies);
        }
        if (valueType) {
            const value = stateMap.get(key);
            if (!value) {
                throw new runtime_1.CompactError(`State map ${stateMap.toString(false)} contains key without corresponding value`);
            }
            // Maps are the only ADT that can contain other ADTs, other maps in particular.
            if (valueType.tag == 'compactValue') {
                compactValueDependencies(valueType.sparseType, stateValueToCompactValue(valueType.descriptor, value), dependencies);
            }
            else {
                compactADTDependencies(valueType, value, dependencies);
            }
        }
    });
};
/**
 * Throw a {@link CompactError} if the input `s` value is undefined. Called when the input {@link StateValue} could not be
 * cast to either a map, array, or boundary Merkle tree representation.
 *
 * @param s The value that is asserted to be defined.
 * @param stateValue The state on which the cast to  a map, array, or boundary Merkle tree representation was attempted.
 * @param expectedCastOutput The representation to which the input state __should__ have been cast.
 */
function assertCastSucceeded(s, stateValue, expectedCastOutput) {
    if (!s) {
        throw new runtime_1.CompactError(`State ${stateValue.toString(false)} cannot be cast to a ${expectedCastOutput}`);
    }
}
/**
 * Extracts the contract references present in the ADT that the input {@link StateValue} represents. Attempts to cast the
 * input state to a different representation indicated by the input {@link SparseCompactADT}.
 *
 * @param sparseCompactADT A data structure pointing to contract references in the Compact ADT represented by the input state.
 * @param stateValue The state representing a Compact ADT.
 * @param dependencies The current set of contract addresses extracted from the input ledger state.
 */
const compactADTDependencies = (sparseCompactADT, stateValue, dependencies) => {
    if (sparseCompactADT.tag == 'cell') {
        compactCellDependencies(sparseCompactADT, stateValue, dependencies);
    }
    else if (sparseCompactADT.tag == 'map') {
        const stateMap = stateValue.asMap();
        assertCastSucceeded(stateMap, stateValue, 'map');
        compactMapADTDependencies(sparseCompactADT, stateMap, dependencies);
    }
    else if (sparseCompactADT.tag == 'list' || sparseCompactADT.tag == 'set') {
        const states = stateValue.asArray();
        assertCastSucceeded(states, stateValue, 'array');
        compactArrayLikeADTDependencies(sparseCompactADT, states, dependencies);
    }
};
/**
 * Converts a {@link StateValue} into an array of state values by calling `asArray`. Throws an error if the cast fails.
 *
 * @param state To state to convert.
 */
const castToStateArray = (state) => {
    const ledgerState = state.asArray();
    assertCastSucceeded(ledgerState, state, 'array');
    return ledgerState;
};
/**
 * Extracts the contract references present in a {@link PublicLedgerSegments} by converting the given state value into
 * a state array, iterating over the entries of {@link PublicLedgerSegments.indices}, and either recurring or calling
 * {@link compactADTDependencies} with a {@link SparseCompactADT} value.
 *
 * @param publicLedgerSegments A data structure pointing to contract references in a segment of the ledger state of
 *                             the root contract.
 * @param state A segment of the ledger state of the root contract.
 * @param dependencies The current set of contract addresses extracted from the input ledger state.
 */
const publicLedgerSegmentsDependencies = (publicLedgerSegments, state, dependencies) => {
    const ledgerState = castToStateArray(state);
    Object.keys(publicLedgerSegments)
        .map(parseInt)
        .forEach((idx) => {
        const referenceLocations = publicLedgerSegments.indices[idx];
        if ('tag' in referenceLocations && referenceLocations['tag'] === 'publicLedgerArray') {
            publicLedgerSegmentsDependencies(referenceLocations, ledgerState[idx], dependencies);
        }
        else {
            compactADTDependencies(referenceLocations, ledgerState[idx], dependencies);
        }
    });
};
/**
 * Given a {@link StateValue} representing the current ledger state of a contract, uses the {@link ContractReferenceLocations}
 * object produced by the Compact compiler to extract the current contract addresses present in the given ledger state. The produced
 * contract addresses represent the contracts on which the root contract depends. The dependencies are used in a multi-contract
 * setting to fetch the ledger states of all contracts on which the root contract depends prior to execution.
 *
 * NOTE: The given {@link ContractReferenceLocations} must be from the contract executable containing the ledger state constructor
 *       that produced the given {@link StateValue}.
 *
 * @param contractReferenceLocations A data structure pointing to contract references in the ledger state of the root contract.
 * @param state The current ledger state of the root contract.
 * @returns A list of all contract addresses (references) present in the given ledger state.
 *
 * @remarks The algorithm has three main stages:
 *
 *          1. It unwraps the {@link PublicLedgerSegments} in the given {@link ContractReferenceLocations} until a {@link SparseCompactADT} is reached.
 *             Each time a {@link PublicLedgerSegments} is unwrapped, it casts the current state value to a state value array and proceeds recursively with each
 *             of the state values and unwrapped ledger segments.
 *          2. It unwraps each {@link SparseCompactADT} in the current {@link PublicLedgerSegments} until a {@link SparseCompactType} is reached.
 *             Each time a {@link SparseCompactADT} is unwrapped, it casts the current state value to a state representation indicated by
 *             the {@link SparseCompactADT}.
 *          3. Once the current state can no longer be reduced, it must represent a Compact contract address somewhere inside the state,
 *             and that contract address is added to the dependency set.
 */
const contractDependencies = (contractReferenceLocations, state) => {
    const dependencies = new Set();
    if (contractReferenceLocations.indices) {
        publicLedgerSegmentsDependencies(contractReferenceLocations, state, dependencies);
    }
    return [...dependencies];
};
exports.contractDependencies = contractDependencies;
//# sourceMappingURL=contract-dependencies.js.map