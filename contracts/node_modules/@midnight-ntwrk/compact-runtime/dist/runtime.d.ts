import * as ocrt from '@midnight-ntwrk/onchain-runtime';
export * from './version';
export { CostModel, Value, Alignment, AlignmentSegment, AlignmentAtom, AlignedValue, Nullifier, CoinCommitment, ContractAddress, TokenType, CoinPublicKey, Nonce, CoinInfo, QualifiedCoinInfo, Fr, Key, Op, GatherResult, BlockContext, Effects, runProgram, ContractOperation, ContractState, ContractMaintenanceAuthority, QueryContext, QueryResults, StateBoundedMerkleTree, StateMap, StateValue, Signature, SigningKey, SignatureVerifyingKey, VmResults, VmStack, DomainSeperator, valueToBigInt, bigIntToValue, maxAlignedSize, coinCommitment, leafHash, NetworkId, sampleContractAddress, sampleTokenType, sampleSigningKey, signData, signatureVerifyingKey, verifySignature, encodeTokenType, decodeTokenType, encodeContractAddress, decodeContractAddress, encodeCoinPublicKey, decodeCoinPublicKey, encodeCoinInfo, encodeQualifiedCoinInfo, decodeCoinInfo, decodeQualifiedCoinInfo, dummyContractAddress, tokenType, } from '@midnight-ntwrk/onchain-runtime';
export { contractDependencies, ContractReferenceLocations, SparseCompactADT, SparseCompactCellADT, SparseCompactArrayLikeADT, SparseCompactMapADT, SparseCompactSetADT, SparseCompactListADT, SparseCompactValue, SparseCompactType, SparseCompactVector, SparseCompactStruct, SparseCompactContractAddress, } from './contract-dependencies';
/**
 * The maximum value representable in Compact's `Field` type
 *
 * One less than the prime modulus of the proof system's scalar field
 */
export declare const MAX_FIELD: bigint;
/**
 * A valid placeholder contract address
 *
 * @deprecated Cannot handle {@link ocrt.NetworkId}s, use
 * {@link ocrt.dummyContractAddress} instead.
 */
export declare const DUMMY_ADDRESS: string;
/**
 * A transcript of operations and their effects, for inclusion and replay in
 * transactions
 */
export type Transcript = ocrt.Transcript<ocrt.AlignedValue>;
/**
 * Concatenates multiple {@link ocrt.AlignedValue}s
 * @internal
 */
export declare function alignedConcat(...values: ocrt.AlignedValue[]): ocrt.AlignedValue;
/**
 * The Compact builtin `transient_hash` function
 *
 * This function is a circuit-efficient compression function from arbitrary
 * data to field elements, which is not guaranteed to persist between upgrades.
 * It should not be used to derive state data, but can be used for consistency
 * checks.
 */
export declare function transientHash<a>(rt_type: CompactType<a>, value: a): bigint;
/**
 * The Compact builtin `transient_commit` function
 *
 * This function is a circuit-efficient commitment function from arbitrary
 * values representable in Compact, and a field element commitment opening, to
 * field elements, which is not guaranteed to persist between
 * upgrades. It should not be used to derive state data, but can be used for
 * consistency checks.
 *
 * @throws If `opening` is out of range for field elements
 */
export declare function transientCommit<a>(rt_type: CompactType<a>, value: a, opening: bigint): bigint;
/**
 * The Compact builtin `persistent_hash` function
 *
 * This function is a non-circuit-optimised hash function for mostly arbitrary
 * data. It is guaranteed to persist between upgrades, with the exception of
 * devnet. It *should* be used to derive state data, and not for consistency
 * checks where avoidable.
 *
 * Note that data containing `Opaque` elements *may* throw runtime errors, and
 * cannot be relied upon as a consistent representation.
 *
 * @throws If `rt_type` encodes a type containing Compact 'Opaque' types
 */
export declare function persistentHash<a>(rt_type: CompactType<a>, value: a): Uint8Array;
/**
 * The Compact builtin `persistent_commit` function
 *
 * This function is a non-circuit-optimised commitment function from arbitrary
 * values representable in Compact, and a 256-bit bytestring opening, to a
 * 256-bit bytestring. It is guaranteed to persist between upgrades. It
 * *should* be used to derive state data, and not for consistency checks where
 * avoidable.
 *
 * Note that data containing `Opaque` elements *may* throw runtime errors, and
 * cannot be relied upon as a consistent representation.
 *
 * @throws If `rt_type` encodes a type containing Compact 'Opaque' types, or
 * `opening` is not 32 bytes long
 */
export declare function persistentCommit<a>(rt_type: CompactType<a>, value: a, opening: Uint8Array): Uint8Array;
/**
 * The Compact builtin `degrade_to_transient` function
 *
 * This function "degrades" the output of a {@link persistentHash} or
 * {@link persistentCommit} to a field element, which can then be used in
 * {@link transientHash} or {@link transientCommit}.
 *
 * @throws If `x` is not 32 bytes long
 */
export declare function degradeToTransient(x: Uint8Array): bigint;
/**
 * The Compact builtin `upgrade_from_transient` function
 *
 * This function "upgrades" the output of a {@link transientHash} or
 * {@link transientCommit} to 256-bit byte string, which can then be used in
 * {@link persistentHash} or {@link persistentCommit}.
 *
 * @throws If `x` is not a valid field element
 */
export declare function upgradeFromTransient(x: bigint): Uint8Array;
/**
 * The Compact builtin `hash_to_curve` function
 *
 * This function maps arbitrary values representable in Compact to elliptic
 * curve points in the proof system's embedded curve.
 *
 * Outputs are guaranteed to have unknown discrete logarithm with respect to
 * the group base, and any other output, but are not guaranteed to be unique (a
 * given input can be proven correct for multiple outputs).
 *
 * Inputs of different types may have the same output, if they have the same
 * field-aligned binary representation.
 */
export declare function hashToCurve<a>(rt_type: CompactType<a>, x: a): CurvePoint;
/**
 * The Compact builtin `ec_add` function
 *
 * This function add two elliptic curve points (in multiplicative notation)
 */
export declare function ecAdd(a: CurvePoint, b: CurvePoint): CurvePoint;
/**
 * The Compact builtin `ec_mul` function
 *
 * This function multiplies an elliptic curve point by a scalar (in
 * multiplicative notation)
 */
export declare function ecMul(a: CurvePoint, b: bigint): CurvePoint;
/**
 * The Compact builtin `ec_mul_generator` function
 *
 * This function multiplies the primary group generator of the embedded curve
 * by a scalar (in multiplicative notation)
 */
export declare function ecMulGenerator(b: bigint): CurvePoint;
/**
 * The recipient of a coin produced by a circuit.
 */
export interface Recipient {
    /**
     * Whether the recipient is a user or a contract.
     */
    readonly is_left: boolean;
    /**
     * The recipient's public key, if the recipient is a user.
     */
    readonly left: ocrt.CoinPublicKey;
    /**
     * The recipient's contract address, if the recipient is a contract.
     */
    readonly right: ocrt.ContractAddress;
}
/**
 * A {@link ocrt.CoinPublicKey} encoded as a byte string. This representation is used internally by the contract executable.
 */
export interface EncodedCoinPublicKey {
    /**
     * The coin public key's bytes.
     */
    readonly bytes: Uint8Array;
}
/**
 * Tracks the coins consumed and produced throughout circuit execution.
 */
export interface EncodedZswapLocalState {
    /**
     * The Zswap coin public key of the user executing the circuit.
     */
    coinPublicKey: EncodedCoinPublicKey;
    /**
     * The Merkle tree index of the next coin produced.
     */
    currentIndex: bigint;
    /**
     * The coins consumed as inputs to the circuit.
     */
    inputs: EncodedQualifiedCoinInfo[];
    /**
     * The coins produced as outputs from the circuit.
     */
    outputs: {
        coinInfo: EncodedCoinInfo;
        recipient: EncodedRecipient;
    }[];
}
/**
 * Constructs a new {@link EncodedZswapLocalState} with the given coin public key. The result can be used to create a
 * {@link ConstructorContext}.
 *
 * @param coinPublicKey The Zswap coin public key of the user executing the circuit.
 */
export declare const emptyZswapLocalState: (coinPublicKey: ocrt.CoinPublicKey) => EncodedZswapLocalState;
/**
 * Converts an {@link Recipient} to an {@link EncodedRecipient}. Useful for testing.
 */
export declare const encodeRecipient: ({ is_left, left, right }: Recipient) => EncodedRecipient;
/**
 * Converts a {@link ZswapLocalState} to an {@link EncodedZswapLocalState}. Useful for testing.
 *
 * @param state The decoded Zswap local state.
 */
export declare const encodeZswapLocalState: (state: ZswapLocalState) => EncodedZswapLocalState;
/**
 * Tracks the coins consumed and produced throughout circuit execution.
 */
export interface ZswapLocalState {
    /**
     * The Zswap coin public key of the user executing the circuit.
     */
    coinPublicKey: ocrt.CoinPublicKey;
    /**
     * The Merkle tree index of the next coin produced.
     */
    currentIndex: bigint;
    /**
     * The coins consumed as inputs to the circuit.
     */
    inputs: ocrt.QualifiedCoinInfo[];
    /**
     * The coins produced as outputs from the circuit.
     */
    outputs: {
        coinInfo: ocrt.CoinInfo;
        recipient: Recipient;
    }[];
}
/**
 * Converts an {@link EncodedRecipient} to a {@link Recipient}.
 */
export declare const decodeRecipient: ({ is_left, left, right }: EncodedRecipient) => Recipient;
/**
 * Converts an {@link EncodedZswapLocalState} to a {@link ZswapLocalState}. Used when we need to use data from contract
 * execution to construct transactions.
 *
 * @param state The encoded Zswap local state.
 */
export declare const decodeZswapLocalState: (state: EncodedZswapLocalState) => ZswapLocalState;
/**
 * The external information accessible from within a Compact circuit call
 */
export interface CircuitContext<T> {
    /**
     * The original contract state the circuit call was started at.
     */
    originalState: ocrt.ContractState;
    /**
     * The current private state for the contract.
     */
    currentPrivateState: T;
    /**
     * The current Zswap local state. Tracks inputs and outputs produced during circuit execution.
     */
    currentZswapLocalState: EncodedZswapLocalState;
    /**
     * The current on-chain context the transaction is evolving.
     */
    transactionContext: ocrt.QueryContext;
}
/**
 * A {@link ocrt.QualifiedCoinInfo} with its fields encoded as byte strings. This representation is used internally by
 * the contract executable.
 */
export interface EncodedQualifiedCoinInfo {
    /**
     * The coin's randomness, preventing it from colliding with other coins.
     */
    readonly nonce: Uint8Array;
    /**
     * The coin's type, identifying the currency it represents.
     */
    readonly color: Uint8Array;
    /**
     * The coin's value, in atomic units dependent on the currency. Bounded to be a non-negative 64-bit integer.
     */
    readonly value: bigint;
    /**
     * The coin's location in the chain's Merkle tree of coin commitments. Bounded to be a non-negative 64-bit integer.
     */
    readonly mt_index: bigint;
}
/**
 * Adds a coin to the list of inputs consumed by the circuit.
 *
 * @param circuitContext The current circuit context.
 * @param qualifiedCoinInfo The input to consume.
 */
export declare function createZswapInput(circuitContext: CircuitContext<unknown>, qualifiedCoinInfo: EncodedQualifiedCoinInfo): void;
/**
 * A {@link ocrt.CoinInfo} with its fields encoded as byte strings. This representation is used internally by
 * the contract executable.
 */
export interface EncodedCoinInfo {
    /**
     * The coin's randomness, preventing it from colliding with other coins.
     */
    readonly nonce: Uint8Array;
    /**
     * The coin's type, identifying the currency it represents.
     */
    readonly color: Uint8Array;
    /**
     * The coin's value, in atomic units dependent on the currency. Bounded to be a non-negative 64-bit integer.
     */
    readonly value: bigint;
}
/**
 * A {@link ocrt.ContractAddress} encoded as a byte string. This representation is used internally by the contract executable.
 */
export interface EncodedContractAddress {
    /**
     * The contract address's bytes.
     */
    readonly bytes: Uint8Array;
}
/**
 * A {@link Recipient} with its fields encoded as byte strings. This representation is used internally by the contract executable.
 */
export interface EncodedRecipient {
    /**
     * Whether the recipient is a user or a contract.
     */
    readonly is_left: boolean;
    /**
     * The recipient's public key, if the recipient is a user.
     */
    readonly left: EncodedCoinPublicKey;
    /**
     * The recipient's contract address, if the recipient is a contract.
     */
    readonly right: EncodedContractAddress;
}
/**
 * Adds a coin to the list of outputs produced by the circuit.
 *
 * @param circuitContext The current circuit context.
 * @param coinInfo The coin to produce.
 * @param recipient The coin recipient - either a coin public key representing an end user or a contract address
 *                  representing a contract.
 */
export declare function createZswapOutput(circuitContext: CircuitContext<unknown>, coinInfo: EncodedCoinInfo, recipient: EncodedRecipient): void;
/**
 * Retrieves the Zswap coin public key of the user executing the circuit.
 *
 * @param circuitContext The current circuit context.
 */
export declare function ownPublicKey(circuitContext: CircuitContext<unknown>): EncodedCoinPublicKey;
/**
 * The external information accessible from within a Compact witness call
 */
export interface WitnessContext<L, T> {
    /**
     * The projected ledger state, if the transaction were to run against the
     * ledger state as you locally see it currently
     */
    readonly ledger: L;
    /**
     * The current private state for the contract
     */
    readonly privateState: T;
    /**
     * The address of the contract being called
     */
    readonly contractAddress: string;
}
/**
 * Internal constructor for {@link WitnessContext}.
 * @internal
 */
export declare function witnessContext<L, T>(ledger: L, privateState: T, contractAddress: ocrt.ContractAddress): WitnessContext<L, T>;
/**
 * Encapsulates the data required to produce a zero-knowledge proof
 */
export interface ProofData {
    /**
     * The inputs to a circuit
     */
    input: ocrt.AlignedValue;
    /**
     * The outputs from a circuit
     */
    output: ocrt.AlignedValue;
    /**
     * The public transcript of operations
     */
    publicTranscript: ocrt.Op<ocrt.AlignedValue>[];
    /**
     * The transcript of the witness call outputs
     */
    privateTranscriptOutputs: ocrt.AlignedValue[];
}
/**
 * Verifies a given {@link ProofData} satisfies the constrains of a ZK circuit
 * descripted by given IR
 *
 * @throws If the circuit is not satisfied
 */
export declare function checkProofData(zkir: string, proofData: ProofData): void;
/**
 * The results of the call to a Compact circuit
 */
export interface CircuitResults<T, U> {
    /**
     * The primary result, as returned from Compact
     */
    result: U;
    /**
     * The data required to prove this circuit run
     */
    proofData: ProofData;
    /**
     * The updated context after the circuit execution, that can be used to
     * inform further runs
     */
    context: CircuitContext<T>;
}
/**
 * Passed to the constructor of a contract. Used to compute the contract's initial ledger state.
 */
export interface ConstructorContext<T> {
    /**
     * The private state we would like to use to execute the contract's constructor.
     */
    initialPrivateState: T;
    /**
     * An initial (usually empty) Zswap local state to use to execute the contract's constructor.
     */
    initialZswapLocalState: EncodedZswapLocalState;
}
/**
 * Creates a new {@link ConstructorContext} with the given initial private state and an empty Zswap local state.
 *
 * @param initialPrivateState The private state to use to execute the contract's constructor.
 * @param coinPublicKey The Zswap coin public key of the user executing the contract.
 */
export declare const constructorContext: <T>(initialPrivateState: T, coinPublicKey: ocrt.CoinPublicKey) => ConstructorContext<T>;
/**
 * The result of executing a contract constructor.
 */
export interface ConstructorResult<T> {
    /**
     * The contract's initial ledger (public state).
     */
    currentContractState: ocrt.ContractState;
    /**
     * The contract's initial private state. Potentially different from the private state passed in {@link ConstructorContext}.
     */
    currentPrivateState: T;
    /**
     * The contract's initial Zswap local state. Potentially includes outputs created in the contract's constructor.
     */
    currentZswapLocalState: EncodedZswapLocalState;
}
/**
 * A runtime representation of a type in Compact
 */
export interface CompactType<a> {
    /**
     * The field-aligned binary alignment of this type.
     */
    alignment(): ocrt.Alignment;
    /**
     * Converts this type's TypeScript representation to its field-aligned binary
     * representation
     */
    toValue(value: a): ocrt.Value;
    /**
     * Converts this type's field-aligned binary representation to its TypeScript
     * representation destructively; (partially) consuming the input, and
     * ignoring superflous data for chaining.
     */
    fromValue(value: ocrt.Value): a;
}
/**
 * A point in the embedded elliptic curve. TypeScript representation of the
 * Compact type of the same name
 */
export interface CurvePoint {
    readonly x: bigint;
    readonly y: bigint;
}
/**
 * The hash value of a Merkle tree. TypeScript representation of the Compact
 * type of the same name
 */
export interface MerkleTreeDigest {
    readonly field: bigint;
}
/**
 * An entry in a Merkle path. TypeScript representation of the Compact type of
 * the same name.
 */
export interface MerkleTreePathEntry {
    readonly sibling: MerkleTreeDigest;
    readonly goes_left: boolean;
}
/**
 * A path demonstrating inclusion in a Merkle tree. TypeScript representation
 * of the Compact type of the same name.
 */
export interface MerkleTreePath<a> {
    readonly leaf: a;
    readonly path: MerkleTreePathEntry[];
}
/**
 * Runtime type of {@link CurvePoint}
 */
export declare class CompactTypeCurvePoint implements CompactType<CurvePoint> {
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): CurvePoint;
    toValue(value: CurvePoint): ocrt.Value;
}
/**
 * Runtime type of {@link MerkleTreeDigest}
 */
export declare class CompactTypeMerkleTreeDigest implements CompactType<MerkleTreeDigest> {
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): MerkleTreeDigest;
    toValue(value: MerkleTreeDigest): ocrt.Value;
}
/**
 * Runtime type of {@link MerkleTreePathEntry}
 */
export declare class CompactTypeMerkleTreePathEntry implements CompactType<MerkleTreePathEntry> {
    readonly digest: CompactTypeMerkleTreeDigest;
    readonly bool: CompactTypeBoolean;
    constructor();
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): MerkleTreePathEntry;
    toValue(value: MerkleTreePathEntry): ocrt.Value;
}
/**
 * Runtime type of {@link MerkleTreePath}
 */
export declare class CompactTypeMerkleTreePath<a> implements CompactType<MerkleTreePath<a>> {
    readonly leaf: CompactType<a>;
    readonly path: CompactTypeVector<MerkleTreePathEntry>;
    constructor(n: number, leaf: CompactType<a>);
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): MerkleTreePath<a>;
    toValue(value: MerkleTreePath<a>): ocrt.Value;
}
/**
 * Runtime type of the builtin `Field` type
 */
export declare class CompactTypeField implements CompactType<bigint> {
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): bigint;
    toValue(value: bigint): ocrt.Value;
}
/**
 * Runtime type of an enum with a given number of entries
 */
export declare class CompactTypeEnum implements CompactType<number> {
    readonly maxValue: number;
    readonly length: number;
    constructor(maxValue: number, length: number);
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): number;
    toValue(value: number): ocrt.Value;
}
/**
 * Runtime type of the builtin `Unsigned Integer` types
 */
export declare class CompactTypeUnsignedInteger implements CompactType<bigint> {
    readonly maxValue: bigint;
    readonly length: number;
    constructor(maxValue: bigint, length: number);
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): bigint;
    toValue(value: bigint): ocrt.Value;
}
/**
 * Runtime type of the builtin `Vector` types
 */
export declare class CompactTypeVector<a> implements CompactType<a[]> {
    readonly length: number;
    readonly type: CompactType<a>;
    constructor(length: number, type: CompactType<a>);
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): a[];
    toValue(value: a[]): ocrt.Value;
}
/**
 * Runtime type of the builtin `Boolean` type
 */
export declare class CompactTypeBoolean implements CompactType<boolean> {
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): boolean;
    toValue(value: boolean): ocrt.Value;
}
/**
 * Runtime type of the builtin `Bytes` types
 */
export declare class CompactTypeBytes implements CompactType<Uint8Array> {
    readonly length: number;
    constructor(length: number);
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): Uint8Array;
    toValue(value: Uint8Array): ocrt.Value;
}
/**
 * Runtime type of `Opaque["Uint8Array"]`
 */
export declare class CompactTypeOpaqueUint8Array implements CompactType<Uint8Array> {
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): Uint8Array;
    toValue(value: Uint8Array): ocrt.Value;
}
/**
 * Runtime type of `Opaque["string"]`
 */
export declare class CompactTypeOpaqueString implements CompactType<string> {
    alignment(): ocrt.Alignment;
    fromValue(value: ocrt.Value): string;
    toValue(value: string): ocrt.Value;
}
/**
 * An error originating from code generated by the Compact compiler
 */
export declare class CompactError extends Error {
    constructor(msg: string);
}
/**
 * Compiler internal for assertions
 * @internal
 */
export declare function assert(b: boolean, s: string): void;
/**
 * Compiler internal for type errors
 * @internal
 */
export declare function type_error(who: string, what: string, where: string, type: string, x: any): never;
/**
 * Compiler internal for typecasts
 * @internal
 */
export declare function convert_bigint_to_Uint8Array(n: number, x: bigint): Uint8Array;
/**
 * Compiler internal for typecasts
 * @internal
 */
export declare function convert_Uint8Array_to_bigint(n: number, a: Uint8Array): bigint;
/**
 * Field addition
 * returns the result of adding x and y, wrapping if necessary
 * x and y are assumed to be values in the range [0, FIELD_MODULUS)
 */
export declare function addField(x: bigint, y: bigint): bigint;
/**
 * Field subtraction
 * returns the result of subtracting y from x, wrapping if necessary
 * x and y are assumed to be values in the range [0, FIELD_MODULUS)
 */
export declare function subField(x: bigint, y: bigint): bigint;
/**
 * Field multiplication
 * returns the result of multipying x and y, wrapping if necessary
 * x and y are assumed to be values in the range [0, FIELD_MODULUS)
 */
export declare function mulField(x: bigint, y: bigint): bigint;
