import { ContractAddress, StateValue } from '@midnight-ntwrk/onchain-runtime';
import { CompactType } from './runtime';
/**
 * A data structure indicating that the current {@link CompactValue} being explored is a contract reference. When this
 * type is recognized, the current {@link CompactValue} should be a {@link ContractAddress}, and the address is added to
 * the dependency set.
 */
export type SparseCompactContractAddress = {
    tag: 'contractAddress';
};
/**
 * A data structure indicating the locations of contract references in a Compact struct.
 */
export type SparseCompactStruct = {
    tag: 'struct';
    /**
     * A data structure indicating the locations of contract references in the elements of a Compact struct. The keys of
     * the record correspond to fields of the Compact struct that contain contract references. We use the keys of the record
     * to explore the elements of the corresponding {@link CompactStruct}.
     */
    elements: Record<string, SparseCompactType>;
};
/**
 * A data structure indicating the locations of contract references in a Compact vector.
 */
export type SparseCompactVector = {
    tag: 'vector';
    /**
     * A data structure indicating the locations of contract references in the elements of a Compact vector.
     */
    sparseType: SparseCompactType;
};
/**
 * A data structure indicating the locations of contract references in a Compact struct, vector, or (the terminating case)
 * a contract address.
 */
export type SparseCompactType = SparseCompactVector | SparseCompactStruct | SparseCompactContractAddress;
/**
 * A data structure indicating the locations of all contract references in a Compact value.
 */
export type SparseCompactValue = {
    tag: 'compactValue';
    /**
     * A descriptor that can be used to convert an {@link AlignedValue} into a TypeScript representation of the same value.
     * This descriptor will only ever decode `struct`s or `Vector`s that contain contract addresses.
     */
    descriptor: CompactType<unknown>;
    /**
     * A data structure indicating how to navigate to the contract addresses present in the output of the above `descriptor`.
     */
    sparseType: SparseCompactType;
};
/**
 * A data structure indicating the locations of all contract references in a Compact `Cell` ADT.
 */
export type SparseCompactCellADT = {
    tag: 'cell';
    /**
     * A data structure indicating the locations of all contract references in the Compact value contained in the outer `Cell` ADT.
     */
    valueType: SparseCompactValue;
};
/**
 * A data structure indicating the locations of all contract references in a Compact `Set` ADT.
 */
export type SparseCompactSetADT = {
    tag: 'set';
    /**
     * A data structure indicating the locations of all contract references in a Compact value in the outer `Set` ADT.
     */
    valueType: SparseCompactValue;
};
/**
 * A data structure indicating the locations of all contract references in a Compact `List` ADT.
 */
export type SparseCompactListADT = {
    tag: 'list';
    /**
     * A data structure indicating the locations of all contract references in a Compact value in the outer `List` ADT.
     */
    valueType: SparseCompactValue;
};
/**
 * A data structure indicating the locations of all contract references in a Compact `Set` or `List` ADT.
 */
export type SparseCompactArrayLikeADT = SparseCompactSetADT | SparseCompactListADT;
/**
 * A data structure indicating the locations of all contract references in a Compact `Map` ADT.
 */
export type SparseCompactMapADT = {
    tag: 'map';
    /**
     * A data structure indicating the locations of all contract references in the Compact values that are the keys of the
     * outer `Map` ADT.
     */
    keyType?: SparseCompactValue;
    /**
     * A data structure indicating the locations of all contract references in the Compact entities that are the values of the
     * outer `Map` ADT. Since the values of a `Map` ADT may be either Compact values or other `Map` ADTs, we take the union
     * of the corresponding data structures.
     */
    valueType?: SparseCompactADT | SparseCompactValue;
};
/**
 * A discriminated union describing the locations of contract references in either a Compact `Cell`, `List`, `Set`, or `Map` ADT.
 */
export type SparseCompactADT = SparseCompactCellADT | SparseCompactArrayLikeADT | SparseCompactMapADT;
/**
 * A data structure indicating the locations of all contract references in a given ledger state.
 */
export type PublicLedgerSegments = {
    tag: 'publicLedgerArray';
    /**
     * For reasonably small ledger states, the keys of the record identify locations of ADTs in the ledger state. For example,
     * if a Compact source file contains
     *
     * ```
     * contract C {};
     * struct Struct1 {
     *   a: Field;
     *   b: C;
     * }
     * ledger ls1: List[Field];
     * ledger ls2: List[C];
     * ledger ls3: Set[Struct1];
     * ```
     *
     * then the indices record will contain keys `1` and `2`, since ledger declarations `1` and `2` contain contract
     * references while ledger declaration `0` (`List[Field]`) does not.
     *
     * However, the ledger implementation has a fixed maximum length on the state arrays produced by {@link StateValue.toArray}.
     * When the number of entries in a given state exceeds the maximum, {@link StateValue.toArray} produces nested state arrays,
     * where each inner state array is within the maximum. For each nested state array, there will be a key in the indices record
     * pointing to a {@link PublicLedgerSegments} object.
     */
    indices: Record<number, PublicLedgerSegments | SparseCompactADT>;
};
/**
 * A type indicating that no contract references are present in a contract's ledger state.
 */
export type EmptyPublicLedger = {
    tag: 'publicLedgerArray';
    indices: undefined;
};
/**
 * A data structure indicating the locations of all contract references in a given ledger state. If it is a {@link EmptyPublicLedger},
 * then no contract references are present in the ledger state. If it is a {@link PublicLedgerSegments}, then contract references are
 * present and can be extracted using {@link contractDependencies}.
 */
export type ContractReferenceLocations = EmptyPublicLedger | PublicLedgerSegments;
/**
 * Given a {@link StateValue} representing the current ledger state of a contract, uses the {@link ContractReferenceLocations}
 * object produced by the Compact compiler to extract the current contract addresses present in the given ledger state. The produced
 * contract addresses represent the contracts on which the root contract depends. The dependencies are used in a multi-contract
 * setting to fetch the ledger states of all contracts on which the root contract depends prior to execution.
 *
 * NOTE: The given {@link ContractReferenceLocations} must be from the contract executable containing the ledger state constructor
 *       that produced the given {@link StateValue}.
 *
 * @param contractReferenceLocations A data structure pointing to contract references in the ledger state of the root contract.
 * @param state The current ledger state of the root contract.
 * @returns A list of all contract addresses (references) present in the given ledger state.
 *
 * @remarks The algorithm has three main stages:
 *
 *          1. It unwraps the {@link PublicLedgerSegments} in the given {@link ContractReferenceLocations} until a {@link SparseCompactADT} is reached.
 *             Each time a {@link PublicLedgerSegments} is unwrapped, it casts the current state value to a state value array and proceeds recursively with each
 *             of the state values and unwrapped ledger segments.
 *          2. It unwraps each {@link SparseCompactADT} in the current {@link PublicLedgerSegments} until a {@link SparseCompactType} is reached.
 *             Each time a {@link SparseCompactADT} is unwrapped, it casts the current state value to a state representation indicated by
 *             the {@link SparseCompactADT}.
 *          3. Once the current state can no longer be reduced, it must represent a Compact contract address somewhere inside the state,
 *             and that contract address is added to the dependency set.
 */
export declare const contractDependencies: (contractReferenceLocations: ContractReferenceLocations, state: StateValue) => ContractAddress[];
