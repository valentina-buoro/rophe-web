"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompactTypeField = exports.CompactTypeMerkleTreePath = exports.CompactTypeMerkleTreePathEntry = exports.CompactTypeMerkleTreeDigest = exports.CompactTypeCurvePoint = exports.constructorContext = exports.decodeZswapLocalState = exports.decodeRecipient = exports.encodeZswapLocalState = exports.encodeRecipient = exports.emptyZswapLocalState = exports.DUMMY_ADDRESS = exports.MAX_FIELD = exports.contractDependencies = exports.tokenType = exports.dummyContractAddress = exports.decodeQualifiedCoinInfo = exports.decodeCoinInfo = exports.encodeQualifiedCoinInfo = exports.encodeCoinInfo = exports.decodeCoinPublicKey = exports.encodeCoinPublicKey = exports.decodeContractAddress = exports.encodeContractAddress = exports.decodeTokenType = exports.encodeTokenType = exports.verifySignature = exports.signatureVerifyingKey = exports.signData = exports.sampleSigningKey = exports.sampleTokenType = exports.sampleContractAddress = exports.NetworkId = exports.leafHash = exports.coinCommitment = exports.maxAlignedSize = exports.bigIntToValue = exports.valueToBigInt = exports.VmStack = exports.VmResults = exports.StateValue = exports.StateMap = exports.StateBoundedMerkleTree = exports.QueryResults = exports.QueryContext = exports.ContractMaintenanceAuthority = exports.ContractState = exports.ContractOperation = exports.runProgram = exports.CostModel = void 0;
exports.CompactError = exports.CompactTypeOpaqueString = exports.CompactTypeOpaqueUint8Array = exports.CompactTypeBytes = exports.CompactTypeBoolean = exports.CompactTypeVector = exports.CompactTypeUnsignedInteger = exports.CompactTypeEnum = void 0;
exports.alignedConcat = alignedConcat;
exports.transientHash = transientHash;
exports.transientCommit = transientCommit;
exports.persistentHash = persistentHash;
exports.persistentCommit = persistentCommit;
exports.degradeToTransient = degradeToTransient;
exports.upgradeFromTransient = upgradeFromTransient;
exports.hashToCurve = hashToCurve;
exports.ecAdd = ecAdd;
exports.ecMul = ecMul;
exports.ecMulGenerator = ecMulGenerator;
exports.createZswapInput = createZswapInput;
exports.createZswapOutput = createZswapOutput;
exports.ownPublicKey = ownPublicKey;
exports.witnessContext = witnessContext;
exports.checkProofData = checkProofData;
exports.assert = assert;
exports.type_error = type_error;
exports.convert_bigint_to_Uint8Array = convert_bigint_to_Uint8Array;
exports.convert_Uint8Array_to_bigint = convert_Uint8Array_to_bigint;
exports.addField = addField;
exports.subField = subField;
exports.mulField = mulField;
const inspect = require("object-inspect");
const ocrt = require("@midnight-ntwrk/onchain-runtime");
__exportStar(require("./version"), exports);
var onchain_runtime_1 = require("@midnight-ntwrk/onchain-runtime");
Object.defineProperty(exports, "CostModel", { enumerable: true, get: function () { return onchain_runtime_1.CostModel; } });
Object.defineProperty(exports, "runProgram", { enumerable: true, get: function () { return onchain_runtime_1.runProgram; } });
Object.defineProperty(exports, "ContractOperation", { enumerable: true, get: function () { return onchain_runtime_1.ContractOperation; } });
Object.defineProperty(exports, "ContractState", { enumerable: true, get: function () { return onchain_runtime_1.ContractState; } });
Object.defineProperty(exports, "ContractMaintenanceAuthority", { enumerable: true, get: function () { return onchain_runtime_1.ContractMaintenanceAuthority; } });
Object.defineProperty(exports, "QueryContext", { enumerable: true, get: function () { return onchain_runtime_1.QueryContext; } });
Object.defineProperty(exports, "QueryResults", { enumerable: true, get: function () { return onchain_runtime_1.QueryResults; } });
Object.defineProperty(exports, "StateBoundedMerkleTree", { enumerable: true, get: function () { return onchain_runtime_1.StateBoundedMerkleTree; } });
Object.defineProperty(exports, "StateMap", { enumerable: true, get: function () { return onchain_runtime_1.StateMap; } });
Object.defineProperty(exports, "StateValue", { enumerable: true, get: function () { return onchain_runtime_1.StateValue; } });
Object.defineProperty(exports, "VmResults", { enumerable: true, get: function () { return onchain_runtime_1.VmResults; } });
Object.defineProperty(exports, "VmStack", { enumerable: true, get: function () { return onchain_runtime_1.VmStack; } });
Object.defineProperty(exports, "valueToBigInt", { enumerable: true, get: function () { return onchain_runtime_1.valueToBigInt; } });
Object.defineProperty(exports, "bigIntToValue", { enumerable: true, get: function () { return onchain_runtime_1.bigIntToValue; } });
Object.defineProperty(exports, "maxAlignedSize", { enumerable: true, get: function () { return onchain_runtime_1.maxAlignedSize; } });
Object.defineProperty(exports, "coinCommitment", { enumerable: true, get: function () { return onchain_runtime_1.coinCommitment; } });
Object.defineProperty(exports, "leafHash", { enumerable: true, get: function () { return onchain_runtime_1.leafHash; } });
Object.defineProperty(exports, "NetworkId", { enumerable: true, get: function () { return onchain_runtime_1.NetworkId; } });
Object.defineProperty(exports, "sampleContractAddress", { enumerable: true, get: function () { return onchain_runtime_1.sampleContractAddress; } });
Object.defineProperty(exports, "sampleTokenType", { enumerable: true, get: function () { return onchain_runtime_1.sampleTokenType; } });
Object.defineProperty(exports, "sampleSigningKey", { enumerable: true, get: function () { return onchain_runtime_1.sampleSigningKey; } });
Object.defineProperty(exports, "signData", { enumerable: true, get: function () { return onchain_runtime_1.signData; } });
Object.defineProperty(exports, "signatureVerifyingKey", { enumerable: true, get: function () { return onchain_runtime_1.signatureVerifyingKey; } });
Object.defineProperty(exports, "verifySignature", { enumerable: true, get: function () { return onchain_runtime_1.verifySignature; } });
Object.defineProperty(exports, "encodeTokenType", { enumerable: true, get: function () { return onchain_runtime_1.encodeTokenType; } });
Object.defineProperty(exports, "decodeTokenType", { enumerable: true, get: function () { return onchain_runtime_1.decodeTokenType; } });
Object.defineProperty(exports, "encodeContractAddress", { enumerable: true, get: function () { return onchain_runtime_1.encodeContractAddress; } });
Object.defineProperty(exports, "decodeContractAddress", { enumerable: true, get: function () { return onchain_runtime_1.decodeContractAddress; } });
Object.defineProperty(exports, "encodeCoinPublicKey", { enumerable: true, get: function () { return onchain_runtime_1.encodeCoinPublicKey; } });
Object.defineProperty(exports, "decodeCoinPublicKey", { enumerable: true, get: function () { return onchain_runtime_1.decodeCoinPublicKey; } });
Object.defineProperty(exports, "encodeCoinInfo", { enumerable: true, get: function () { return onchain_runtime_1.encodeCoinInfo; } });
Object.defineProperty(exports, "encodeQualifiedCoinInfo", { enumerable: true, get: function () { return onchain_runtime_1.encodeQualifiedCoinInfo; } });
Object.defineProperty(exports, "decodeCoinInfo", { enumerable: true, get: function () { return onchain_runtime_1.decodeCoinInfo; } });
Object.defineProperty(exports, "decodeQualifiedCoinInfo", { enumerable: true, get: function () { return onchain_runtime_1.decodeQualifiedCoinInfo; } });
Object.defineProperty(exports, "dummyContractAddress", { enumerable: true, get: function () { return onchain_runtime_1.dummyContractAddress; } });
Object.defineProperty(exports, "tokenType", { enumerable: true, get: function () { return onchain_runtime_1.tokenType; } });
var contract_dependencies_1 = require("./contract-dependencies");
Object.defineProperty(exports, "contractDependencies", { enumerable: true, get: function () { return contract_dependencies_1.contractDependencies; } });
/**
 * The maximum value representable in Compact's `Field` type
 *
 * One less than the prime modulus of the proof system's scalar field
 */
exports.MAX_FIELD = ocrt.maxField();
const FIELD_MODULUS = exports.MAX_FIELD + 1n;
/**
 * A valid placeholder contract address
 *
 * @deprecated Cannot handle {@link ocrt.NetworkId}s, use
 * {@link ocrt.dummyContractAddress} instead.
 */
exports.DUMMY_ADDRESS = ocrt.dummyContractAddress();
/**
 * Concatenates multiple {@link ocrt.AlignedValue}s
 * @internal
 */
function alignedConcat(...values) {
    const res = { value: [], alignment: [] };
    for (const value of values) {
        res.value = res.value.concat(value.value);
        res.alignment = res.alignment.concat(value.alignment);
    }
    return res;
}
/**
 * The Compact builtin `transient_hash` function
 *
 * This function is a circuit-efficient compression function from arbitrary
 * data to field elements, which is not guaranteed to persist between upgrades.
 * It should not be used to derive state data, but can be used for consistency
 * checks.
 */
function transientHash(rt_type, value) {
    return ocrt.valueToBigInt(ocrt.transientHash(rt_type.alignment(), rt_type.toValue(value)));
}
/**
 * The Compact builtin `transient_commit` function
 *
 * This function is a circuit-efficient commitment function from arbitrary
 * values representable in Compact, and a field element commitment opening, to
 * field elements, which is not guaranteed to persist between
 * upgrades. It should not be used to derive state data, but can be used for
 * consistency checks.
 *
 * @throws If `opening` is out of range for field elements
 */
function transientCommit(rt_type, value, opening) {
    return ocrt.valueToBigInt(ocrt.transientCommit(rt_type.alignment(), rt_type.toValue(value), ocrt.bigIntToValue(opening)));
}
/**
 * The Compact builtin `persistent_hash` function
 *
 * This function is a non-circuit-optimised hash function for mostly arbitrary
 * data. It is guaranteed to persist between upgrades, with the exception of
 * devnet. It *should* be used to derive state data, and not for consistency
 * checks where avoidable.
 *
 * Note that data containing `Opaque` elements *may* throw runtime errors, and
 * cannot be relied upon as a consistent representation.
 *
 * @throws If `rt_type` encodes a type containing Compact 'Opaque' types
 */
function persistentHash(rt_type, value) {
    const wrapped = ocrt.persistentHash(rt_type.alignment(), rt_type.toValue(value))[0];
    const res = new Uint8Array(32);
    res.set(wrapped, 0);
    return res;
}
/**
 * The Compact builtin `persistent_commit` function
 *
 * This function is a non-circuit-optimised commitment function from arbitrary
 * values representable in Compact, and a 256-bit bytestring opening, to a
 * 256-bit bytestring. It is guaranteed to persist between upgrades. It
 * *should* be used to derive state data, and not for consistency checks where
 * avoidable.
 *
 * Note that data containing `Opaque` elements *may* throw runtime errors, and
 * cannot be relied upon as a consistent representation.
 *
 * @throws If `rt_type` encodes a type containing Compact 'Opaque' types, or
 * `opening` is not 32 bytes long
 */
function persistentCommit(rt_type, value, opening) {
    if (opening.length != 32) {
        throw new CompactError('Expected 32-byte string');
    }
    const wrapped = ocrt.persistentCommit(rt_type.alignment(), rt_type.toValue(value), [opening])[0];
    const res = new Uint8Array(32);
    res.set(wrapped, 0);
    return res;
}
/**
 * The Compact builtin `degrade_to_transient` function
 *
 * This function "degrades" the output of a {@link persistentHash} or
 * {@link persistentCommit} to a field element, which can then be used in
 * {@link transientHash} or {@link transientCommit}.
 *
 * @throws If `x` is not 32 bytes long
 */
function degradeToTransient(x) {
    if (x.length != 32) {
        throw new CompactError('Expected 32-byte string');
    }
    return ocrt.valueToBigInt(ocrt.degradeToTransient([x]));
}
/**
 * The Compact builtin `upgrade_from_transient` function
 *
 * This function "upgrades" the output of a {@link transientHash} or
 * {@link transientCommit} to 256-bit byte string, which can then be used in
 * {@link persistentHash} or {@link persistentCommit}.
 *
 * @throws If `x` is not a valid field element
 */
function upgradeFromTransient(x) {
    const wrapped = ocrt.upgradeFromTransient(ocrt.bigIntToValue(x))[0];
    const res = new Uint8Array(32);
    res.set(wrapped, 0);
    return res;
}
/**
 * The Compact builtin `hash_to_curve` function
 *
 * This function maps arbitrary values representable in Compact to elliptic
 * curve points in the proof system's embedded curve.
 *
 * Outputs are guaranteed to have unknown discrete logarithm with respect to
 * the group base, and any other output, but are not guaranteed to be unique (a
 * given input can be proven correct for multiple outputs).
 *
 * Inputs of different types may have the same output, if they have the same
 * field-aligned binary representation.
 */
function hashToCurve(rt_type, x) {
    return new CompactTypeCurvePoint().fromValue(ocrt.hashToCurve(rt_type.alignment(), rt_type.toValue(x)));
}
/**
 * The Compact builtin `ec_add` function
 *
 * This function add two elliptic curve points (in multiplicative notation)
 */
function ecAdd(a, b) {
    const rt_type = new CompactTypeCurvePoint();
    return rt_type.fromValue(ocrt.ecAdd(rt_type.toValue(a), rt_type.toValue(b)));
}
/**
 * The Compact builtin `ec_mul` function
 *
 * This function multiplies an elliptic curve point by a scalar (in
 * multiplicative notation)
 */
function ecMul(a, b) {
    const rt_type = new CompactTypeCurvePoint();
    return rt_type.fromValue(ocrt.ecMul(rt_type.toValue(a), ocrt.bigIntToValue(b)));
}
/**
 * The Compact builtin `ec_mul_generator` function
 *
 * This function multiplies the primary group generator of the embedded curve
 * by a scalar (in multiplicative notation)
 */
function ecMulGenerator(b) {
    return new CompactTypeCurvePoint().fromValue(ocrt.ecMulGenerator(ocrt.bigIntToValue(b)));
}
/**
 * Constructs a new {@link EncodedZswapLocalState} with the given coin public key. The result can be used to create a
 * {@link ConstructorContext}.
 *
 * @param coinPublicKey The Zswap coin public key of the user executing the circuit.
 */
const emptyZswapLocalState = (coinPublicKey) => ({
    coinPublicKey: { bytes: ocrt.encodeCoinPublicKey(coinPublicKey) },
    currentIndex: 0n,
    inputs: [],
    outputs: [],
});
exports.emptyZswapLocalState = emptyZswapLocalState;
/**
 * Converts an {@link Recipient} to an {@link EncodedRecipient}. Useful for testing.
 */
const encodeRecipient = ({ is_left, left, right }) => ({
    is_left,
    left: { bytes: ocrt.encodeCoinPublicKey(left) },
    right: { bytes: ocrt.encodeContractAddress(right) },
});
exports.encodeRecipient = encodeRecipient;
/**
 * Converts a {@link ZswapLocalState} to an {@link EncodedZswapLocalState}. Useful for testing.
 *
 * @param state The decoded Zswap local state.
 */
const encodeZswapLocalState = (state) => ({
    coinPublicKey: { bytes: ocrt.encodeCoinPublicKey(state.coinPublicKey) },
    currentIndex: state.currentIndex,
    inputs: state.inputs.map(ocrt.encodeQualifiedCoinInfo),
    outputs: state.outputs.map(({ coinInfo, recipient }) => ({
        coinInfo: ocrt.encodeCoinInfo(coinInfo),
        recipient: (0, exports.encodeRecipient)(recipient),
    })),
});
exports.encodeZswapLocalState = encodeZswapLocalState;
/**
 * Converts an {@link EncodedRecipient} to a {@link Recipient}.
 */
const decodeRecipient = ({ is_left, left, right }) => ({
    is_left,
    left: ocrt.decodeCoinPublicKey(left.bytes),
    right: ocrt.decodeContractAddress(right.bytes),
});
exports.decodeRecipient = decodeRecipient;
/**
 * Converts an {@link EncodedZswapLocalState} to a {@link ZswapLocalState}. Used when we need to use data from contract
 * execution to construct transactions.
 *
 * @param state The encoded Zswap local state.
 */
const decodeZswapLocalState = (state) => ({
    coinPublicKey: ocrt.decodeCoinPublicKey(state.coinPublicKey.bytes),
    currentIndex: state.currentIndex,
    inputs: state.inputs.map(ocrt.decodeQualifiedCoinInfo),
    outputs: state.outputs.map(({ coinInfo, recipient }) => ({
        coinInfo: ocrt.decodeCoinInfo(coinInfo),
        recipient: (0, exports.decodeRecipient)(recipient),
    })),
});
exports.decodeZswapLocalState = decodeZswapLocalState;
/**
 * Adds a coin to the list of inputs consumed by the circuit.
 *
 * @param circuitContext The current circuit context.
 * @param qualifiedCoinInfo The input to consume.
 */
function createZswapInput(circuitContext, qualifiedCoinInfo) {
    circuitContext.currentZswapLocalState = {
        ...circuitContext.currentZswapLocalState,
        inputs: circuitContext.currentZswapLocalState.inputs.concat(qualifiedCoinInfo),
    };
}
/**
 * Creates a coin commitment from the given coin information and recipient represented as an Impact value.
 *
 * @param coinInfo The coin.
 * @param recipient The coin recipient.
 *
 * @internal
 */
function createCoinCommitment(coinInfo, recipient) {
    return ocrt.coinCommitment({
        value: coinInfoDescriptor.toValue(coinInfo),
        alignment: coinInfoDescriptor.alignment(),
    }, {
        value: eitherDescriptor.toValue(recipient),
        alignment: eitherDescriptor.alignment(),
    });
}
/**
 * Adds a coin to the list of outputs produced by the circuit.
 *
 * @param circuitContext The current circuit context.
 * @param coinInfo The coin to produce.
 * @param recipient The coin recipient - either a coin public key representing an end user or a contract address
 *                  representing a contract.
 */
function createZswapOutput(circuitContext, coinInfo, recipient) {
    circuitContext.transactionContext = circuitContext.transactionContext.insertCommitment(Buffer.from(bytesDescriptor.fromValue(createCoinCommitment(coinInfo, recipient).value)).toString('hex'), circuitContext.currentZswapLocalState.currentIndex);
    circuitContext.currentZswapLocalState = {
        ...circuitContext.currentZswapLocalState,
        currentIndex: circuitContext.currentZswapLocalState.currentIndex + 1n,
        outputs: circuitContext.currentZswapLocalState.outputs.concat({
            coinInfo,
            recipient,
        }),
    };
}
/**
 * Retrieves the Zswap coin public key of the user executing the circuit.
 *
 * @param circuitContext The current circuit context.
 */
function ownPublicKey(circuitContext) {
    return circuitContext.currentZswapLocalState.coinPublicKey;
}
/**
 * Internal constructor for {@link WitnessContext}.
 * @internal
 */
function witnessContext(ledger, privateState, contractAddress) {
    return {
        ledger,
        privateState,
        contractAddress,
    };
}
/**
 * Verifies a given {@link ProofData} satisfies the constrains of a ZK circuit
 * descripted by given IR
 *
 * @throws If the circuit is not satisfied
 */
function checkProofData(zkir, proofData) {
    return ocrt.checkProofData(zkir, proofData.input, proofData.output, proofData.publicTranscript, proofData.privateTranscriptOutputs);
}
/**
 * Creates a new {@link ConstructorContext} with the given initial private state and an empty Zswap local state.
 *
 * @param initialPrivateState The private state to use to execute the contract's constructor.
 * @param coinPublicKey The Zswap coin public key of the user executing the contract.
 */
const constructorContext = (initialPrivateState, coinPublicKey) => ({
    initialPrivateState,
    initialZswapLocalState: (0, exports.emptyZswapLocalState)(coinPublicKey),
});
exports.constructorContext = constructorContext;
/**
 * Runtime type of {@link CurvePoint}
 */
class CompactTypeCurvePoint {
    alignment() {
        return [
            { tag: 'atom', value: { tag: 'field' } },
            { tag: 'atom', value: { tag: 'field' } },
        ];
    }
    fromValue(value) {
        const x = value.shift();
        const y = value.shift();
        if (x == undefined || y == undefined) {
            throw new CompactError('expected CurvePoint');
        }
        else {
            return {
                x: ocrt.valueToBigInt([x]),
                y: ocrt.valueToBigInt([y]),
            };
        }
    }
    toValue(value) {
        return ocrt.bigIntToValue(value.x).concat(ocrt.bigIntToValue(value.y));
    }
}
exports.CompactTypeCurvePoint = CompactTypeCurvePoint;
/**
 * Runtime type of {@link MerkleTreeDigest}
 */
class CompactTypeMerkleTreeDigest {
    alignment() {
        return [{ tag: 'atom', value: { tag: 'field' } }];
    }
    fromValue(value) {
        const val = value.shift();
        if (val == undefined) {
            throw new CompactError('expected MerkleTreeDigest');
        }
        else {
            return { field: ocrt.valueToBigInt([val]) };
        }
    }
    toValue(value) {
        return ocrt.bigIntToValue(value.field);
    }
}
exports.CompactTypeMerkleTreeDigest = CompactTypeMerkleTreeDigest;
/**
 * Runtime type of {@link MerkleTreePathEntry}
 */
class CompactTypeMerkleTreePathEntry {
    constructor() {
        this.digest = new CompactTypeMerkleTreeDigest();
        this.bool = new CompactTypeBoolean();
    }
    alignment() {
        return this.digest.alignment().concat(this.bool.alignment());
    }
    fromValue(value) {
        const sibling = this.digest.fromValue(value);
        const goes_left = this.bool.fromValue(value);
        return {
            sibling: sibling,
            goes_left: goes_left,
        };
    }
    toValue(value) {
        return this.digest.toValue(value.sibling).concat(this.bool.toValue(value.goes_left));
    }
}
exports.CompactTypeMerkleTreePathEntry = CompactTypeMerkleTreePathEntry;
/**
 * Runtime type of {@link MerkleTreePath}
 */
class CompactTypeMerkleTreePath {
    constructor(n, leaf) {
        this.leaf = leaf;
        this.path = new CompactTypeVector(n, new CompactTypeMerkleTreePathEntry());
    }
    alignment() {
        return this.leaf.alignment().concat(this.path.alignment());
    }
    fromValue(value) {
        const leaf = this.leaf.fromValue(value);
        const path = this.path.fromValue(value);
        return {
            leaf: leaf,
            path: path,
        };
    }
    toValue(value) {
        return this.leaf.toValue(value.leaf).concat(this.path.toValue(value.path));
    }
}
exports.CompactTypeMerkleTreePath = CompactTypeMerkleTreePath;
/**
 * Runtime type of the builtin `Field` type
 */
class CompactTypeField {
    alignment() {
        return [{ tag: 'atom', value: { tag: 'field' } }];
    }
    fromValue(value) {
        const val = value.shift();
        if (val == undefined) {
            throw new CompactError('expected Field');
        }
        else {
            return ocrt.valueToBigInt([val]);
        }
    }
    toValue(value) {
        return ocrt.bigIntToValue(value);
    }
}
exports.CompactTypeField = CompactTypeField;
/**
 * Runtime type of an enum with a given number of entries
 */
class CompactTypeEnum {
    constructor(maxValue, length) {
        this.maxValue = maxValue;
        this.length = length;
    }
    alignment() {
        return [{ tag: 'atom', value: { tag: 'bytes', length: this.length } }];
    }
    fromValue(value) {
        const val = value.shift();
        if (val == undefined) {
            throw new CompactError(`expected Enum[<=${this.maxValue}]`);
        }
        else {
            let res = 0;
            for (let i = 0; i < val.length; i++) {
                res += (1 << (8 * i)) * val[i];
            }
            if (res > this.maxValue) {
                throw new CompactError(`expected UnsignedInteger[<=${this.maxValue}]`);
            }
            return res;
        }
    }
    toValue(value) {
        return new CompactTypeField().toValue(BigInt(value));
    }
}
exports.CompactTypeEnum = CompactTypeEnum;
/**
 * Runtime type of the builtin `Unsigned Integer` types
 */
class CompactTypeUnsignedInteger {
    constructor(maxValue, length) {
        this.maxValue = maxValue;
        this.length = length;
    }
    alignment() {
        return [{ tag: 'atom', value: { tag: 'bytes', length: this.length } }];
    }
    fromValue(value) {
        const val = value.shift();
        if (val == undefined) {
            throw new CompactError(`expected UnsignedInteger[<=${this.maxValue}]`);
        }
        else {
            let res = 0n;
            for (let i = 0; i < val.length; i++) {
                res += (1n << (8n * BigInt(i))) * BigInt(val[i]);
            }
            if (res > this.maxValue) {
                throw new CompactError(`expected UnsignedInteger[<=${this.maxValue}]`);
            }
            return res;
        }
    }
    toValue(value) {
        return new CompactTypeField().toValue(value);
    }
}
exports.CompactTypeUnsignedInteger = CompactTypeUnsignedInteger;
/**
 * Runtime type of the builtin `Vector` types
 */
class CompactTypeVector {
    constructor(length, type) {
        this.length = length;
        this.type = type;
    }
    alignment() {
        const inner = this.type.alignment();
        let res = [];
        for (let i = 0; i < this.length; i++) {
            res = res.concat(inner);
        }
        return res;
    }
    fromValue(value) {
        const res = [];
        for (let i = 0; i < this.length; i++) {
            res.push(this.type.fromValue(value));
        }
        return res;
    }
    toValue(value) {
        if (value.length != this.length) {
            throw new CompactError(`expected ${this.length}-element array`);
        }
        let res = [];
        for (let i = 0; i < this.length; i++) {
            res = res.concat(this.type.toValue(value[i]));
        }
        return res;
    }
}
exports.CompactTypeVector = CompactTypeVector;
/**
 * Runtime type of the builtin `Boolean` type
 */
class CompactTypeBoolean {
    alignment() {
        return [{ tag: 'atom', value: { tag: 'bytes', length: 1 } }];
    }
    fromValue(value) {
        const val = value.shift();
        if (val == undefined || val.length > 1 || (val.length == 1 && val[0] != 1)) {
            throw new CompactError('expected Boolean');
        }
        return val.length == 1;
    }
    toValue(value) {
        if (value) {
            return [new Uint8Array([1])];
        }
        else {
            return [new Uint8Array(0)];
        }
    }
}
exports.CompactTypeBoolean = CompactTypeBoolean;
/**
 * Runtime type of the builtin `Bytes` types
 */
class CompactTypeBytes {
    constructor(length) {
        this.length = length;
    }
    alignment() {
        return [{ tag: 'atom', value: { tag: 'bytes', length: this.length } }];
    }
    fromValue(value) {
        const val = value.shift();
        if (val == undefined || val.length > this.length) {
            throw new CompactError(`expected Bytes[${this.length}]`);
        }
        if (val.length == this.length) {
            return val;
        }
        const res = new Uint8Array(this.length);
        res.set(val, 0);
        return res;
    }
    toValue(value) {
        let end = value.length;
        while (end > 0 && value[end - 1] == 0) {
            end -= 1;
        }
        return [value.slice(0, end)];
    }
}
exports.CompactTypeBytes = CompactTypeBytes;
/**
 * Runtime type of `Opaque["Uint8Array"]`
 */
class CompactTypeOpaqueUint8Array {
    alignment() {
        return [{ tag: 'atom', value: { tag: 'compress' } }];
    }
    fromValue(value) {
        return value.shift();
    }
    toValue(value) {
        return [value];
    }
}
exports.CompactTypeOpaqueUint8Array = CompactTypeOpaqueUint8Array;
/**
 * Runtime type of `Opaque["string"]`
 */
class CompactTypeOpaqueString {
    alignment() {
        return [{ tag: 'atom', value: { tag: 'compress' } }];
    }
    fromValue(value) {
        return new TextDecoder('utf-8').decode(value.shift());
    }
    toValue(value) {
        return [new TextEncoder().encode(value)];
    }
}
exports.CompactTypeOpaqueString = CompactTypeOpaqueString;
/**
 * An error originating from code generated by the Compact compiler
 */
class CompactError extends Error {
    constructor(msg) {
        super(msg);
        this.name = 'CompactError';
    }
}
exports.CompactError = CompactError;
/**
 * Compiler internal for assertions
 * @internal
 */
function assert(b, s) {
    if (!b) {
        const msg = `failed assert: ${s}`;
        throw new CompactError(msg);
    }
}
/**
 * Compiler internal for type errors
 * @internal
 */
function type_error(who, what, where, type, x) {
    const msg = `type error: ${who} ${what} at ${where}; expected value of type ${type} but received ${inspect(x)}`;
    throw new CompactError(msg);
}
/**
 * Compiler internal for typecasts
 * @internal
 */
function convert_bigint_to_Uint8Array(n, x) {
    const x_0 = x;
    const a = new Uint8Array(n);
    // counting on new Uint8Array setting all elements to zero; those not set by the
    // intentionally left with a value of zero
    for (let i = 0; i < n; i++) {
        a[i] = Number(x & 0xffn);
        x = x / 0x100n;
        if (x == 0n)
            return a;
    }
    const msg = `range error: ${x_0} cannot be decomposed into ${n} bytes`;
    throw new CompactError(msg);
}
/**
 * Compiler internal for typecasts
 * @internal
 */
function convert_Uint8Array_to_bigint(n, a) {
    let x = 0n;
    for (let i = n - 1; i >= 0; i -= 1) {
        x = x * 0x100n + BigInt(a[i]);
    }
    if (x > exports.MAX_FIELD) {
        const msg = `range error: ${x} is greater than maximum for the field ${exports.MAX_FIELD}`;
        throw new CompactError(msg);
    }
    return x;
}
/**
 * Field addition
 * returns the result of adding x and y, wrapping if necessary
 * x and y are assumed to be values in the range [0, FIELD_MODULUS)
 */
function addField(x, y) {
    const t = x + y;
    // effectively mod(x + y, FIELD_MODULUS) for x and y in the assumed range
    // (x + y) % FIELD_MODULUS would also work but would likely be more expensive
    return t < FIELD_MODULUS ? t : t - FIELD_MODULUS;
}
/**
 * Field subtraction
 * returns the result of subtracting y from x, wrapping if necessary
 * x and y are assumed to be values in the range [0, FIELD_MODULUS)
 */
function subField(x, y) {
    // effectively mod(x - y, FIELD_MODULUS) for x and y in the assumed range
    // NB: JavaScript % implements remainder rather than modulus, so
    // (x - y) % FIELD_MODULUS would return an incorrect value for negative values of x - y.
    // also, any implementation involving % would likely be more expensive
    const t = x - y;
    return t >= 0 ? t : t + FIELD_MODULUS;
}
/**
 * Field multiplication
 * returns the result of multipying x and y, wrapping if necessary
 * x and y are assumed to be values in the range [0, FIELD_MODULUS)
 */
function mulField(x, y) {
    // effectively mod(x * y, FIELD_MODULUS) for x and y in the assumed range
    // (although JavaScript % implements remainder rather than modulo, remainder
    // and modulo coincide for nonnegative inputs)
    return (x * y) % FIELD_MODULUS;
}
/**
 * The following are type descriptors used to implement {@link createCoinCommitment}. They are not intended for direct
 * consumption.
 */
/**
 * @internal
 */
const bytesDescriptor = new CompactTypeBytes(32);
/**
 * @internal
 */
const uintDescriptor = new CompactTypeUnsignedInteger(18446744073709551615n, 8);
/**
 * @internal
 */
class CoinInfoDescriptor {
    alignment() {
        return bytesDescriptor.alignment().concat(bytesDescriptor.alignment().concat(uintDescriptor.alignment()));
    }
    fromValue(value) {
        return {
            nonce: bytesDescriptor.fromValue(value),
            color: bytesDescriptor.fromValue(value),
            value: uintDescriptor.fromValue(value),
        };
    }
    toValue(value) {
        return bytesDescriptor
            .toValue(value.nonce)
            .concat(bytesDescriptor.toValue(value.color).concat(uintDescriptor.toValue(value.value)));
    }
}
/**
 * @internal
 */
const coinInfoDescriptor = new CoinInfoDescriptor();
/**
 * @internal
 */
class ZswapCoinPublicKeyDescriptor {
    alignment() {
        return bytesDescriptor.alignment();
    }
    fromValue(value) {
        return {
            bytes: bytesDescriptor.fromValue(value),
        };
    }
    toValue(value) {
        return bytesDescriptor.toValue(value.bytes);
    }
}
/**
 * @internal
 */
class ContractAddressDescriptor {
    alignment() {
        return bytesDescriptor.alignment();
    }
    fromValue(value) {
        return {
            bytes: bytesDescriptor.fromValue(value),
        };
    }
    toValue(value) {
        return bytesDescriptor.toValue(value.bytes);
    }
}
/**
 * @internal
 */
const contractAddressDescriptor = new ContractAddressDescriptor();
/**
 * @internal
 */
const zswapCoinPublicKeyDescriptor = new ZswapCoinPublicKeyDescriptor();
/**
 * @internal
 */
const booleanDescriptor = new CompactTypeBoolean();
/**
 * @internal
 */
class EitherDescriptor {
    alignment() {
        return booleanDescriptor
            .alignment()
            .concat(zswapCoinPublicKeyDescriptor.alignment().concat(contractAddressDescriptor.alignment()));
    }
    fromValue(value) {
        return {
            is_left: booleanDescriptor.fromValue(value),
            left: zswapCoinPublicKeyDescriptor.fromValue(value),
            right: contractAddressDescriptor.fromValue(value),
        };
    }
    toValue(value) {
        return booleanDescriptor
            .toValue(value.is_left)
            .concat(zswapCoinPublicKeyDescriptor.toValue(value.left).concat(contractAddressDescriptor.toValue(value.right)));
    }
}
/**
 * @internal
 */
const eitherDescriptor = new EitherDescriptor();
//# sourceMappingURL=runtime.js.map