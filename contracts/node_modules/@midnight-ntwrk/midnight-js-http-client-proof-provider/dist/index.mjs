import fetch from 'cross-fetch';
import fetchBuilder from 'fetch-retry';
import { Transaction } from '@midnight-ntwrk/ledger';
import { BinaryWriter } from '@dao-xyz/borsh';
import { InvalidProtocolSchemeError, createUnbalancedTx } from '@midnight-ntwrk/midnight-js-types';
import _ from 'lodash';
import { getLedgerNetworkId } from '@midnight-ntwrk/midnight-js-network-id';

/**
 * configure fetch-retry with fetch and http error 500 & 503 backoff strategy.
 */
const retryOptions = {
    retries: 3,
    retryDelay: (attempt) => 2 ** attempt * 1_000,
    retryOn: [500, 503]
};
const fetchRetry = fetchBuilder(fetch, retryOptions);
/**
 * Serializes a {@link ZKConfig} using Borsh format.
 *
 * @param zkConfig The configuration to serialize.
 */
const serializeZKConfig = (zkConfig) => {
    // Borsh serialized as a one element hash map with 'circuitId' as a key
    const binaryWriter = new BinaryWriter();
    if (zkConfig) {
        binaryWriter.u32(1);
        binaryWriter.string(zkConfig.circuitId);
        BinaryWriter.uint8ArrayFixed(zkConfig.proverKey, binaryWriter);
        BinaryWriter.uint8ArrayFixed(zkConfig.verifierKey, binaryWriter);
        BinaryWriter.uint8ArrayFixed(zkConfig.zkir, binaryWriter);
    }
    else {
        binaryWriter.u32(0);
    }
    return binaryWriter.finalize();
};
/**
 * Creates a serialized proving server payload from the given transaction and
 * ZK configuration.
 *
 * @param unprovenTx The transaction being proven.
 * @param zkConfig The ZK artifacts needed to prove the transaction. Undefined
 *                 if a deployment transaction is being proven.
 */
const serializePayload = (unprovenTx, zkConfig) => new Blob([unprovenTx.serialize(getLedgerNetworkId()), serializeZKConfig(zkConfig)]).arrayBuffer();
const deserializePayload = (arrayBuffer) => createUnbalancedTx(Transaction.deserialize(new Uint8Array(arrayBuffer), getLedgerNetworkId()));
const PROVE_TX_PATH = '/prove-tx';
/**
 * The default configuration for the proof server client.
 */
const DEFAULT_CONFIG = {
    /**
     * The default timeout for prove requests.
     */
    timeout: 300000,
    /**
     * The default ZK configuration to use. It is overwritten with a proper ZK
     * configuration only if a call transaction is being proven.
     */
    zkConfig: undefined
};
/**
 * Creates a {@link ProofProvider} by creating a client for a running proof server.
 * Allows for HTTP and HTTPS. The data passed to 'proveTx' are intended to be
 * secret, so usage of this function should be heavily scrutinized.
 *
 * @param url The url of a running proof server.
 */
const httpClientProofProvider = (url) => {
    // To validate the url, we use the URL constructor
    const urlObject = new URL(PROVE_TX_PATH, url);
    if (urlObject.protocol !== 'http:' && urlObject.protocol !== 'https:') {
        throw new InvalidProtocolSchemeError(urlObject.protocol, ['http:', 'https:']);
    }
    return {
        async proveTx(unprovenTx, partialProveTxConfig) {
            const config = _.defaults(partialProveTxConfig, DEFAULT_CONFIG);
            const response = await fetchRetry(urlObject, {
                method: 'POST',
                body: await serializePayload(unprovenTx, config.zkConfig),
                signal: AbortSignal.timeout(config.timeout)
            });
            // TODO: More sophisticated error handling
            // TODO: Check that response is valid format (has arrayBuffer content-type)
            if (!response.ok) {
                throw new Error(`Failed Proof Server response: url="${response.url}", code="${response.status}", status="${response.statusText}""`);
            }
            return deserializePayload(await response.arrayBuffer());
        }
    };
};

export { DEFAULT_CONFIG, httpClientProofProvider, serializePayload, serializeZKConfig };
//# sourceMappingURL=index.mjs.map
