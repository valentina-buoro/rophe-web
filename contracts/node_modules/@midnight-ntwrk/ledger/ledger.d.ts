// DO NOT EDIT THIS FILE; IT IS AUTOMATICALLY GENERATED
/**
 * An interactions with a contract
 */
export type ContractAction = ContractCall | ContractDeploy | MaintenanceUpdate;

/**
 * Strictness criteria for evaluating transaction well-formedness, used for
 * disabling parts of transaction validation for testing.
 */
export class WellFormedStrictness {
  constructor();
  /**
   * Whether to require the transaction to have a non-negative balance
   */
  enforceBalancing: boolean;
  /**
   * Whether to validate Midnight-native (non-contract) proofs in the transaction
   */
  verifyNativeProofs: boolean;
  /**
   * Whether to validate contract proofs in the transaction
   */
  verifyContractProofs: boolean;
}

/**
 * The state of the Midnight ledger
 */
export class LedgerState {
  /**
   * Intializes from a Zswap state, with an empty contract set
   */
  constructor(zswap: ZswapChainState);
  /**
   * A fully blank state
   */
  static blank(): LedgerState;
  /**
   * Applies a {@link ProofErasedTransaction}
   */
  apply(transaction: ProofErasedTransaction, context: TransactionContext): [LedgerState, TransactionResult];
  /**
   * Applies a system transaction to this ledger state.
   */
  applySystemTx(transaction: SystemTransaction): LedgerState;
  /**
   * Indexes into the contract state map with a given contract address
   */
  index(address: ContractAddress): ContractState | undefined;
  /**
   * Sets the state of a given contract address from a {@link QueryContext}
   */
  updateIndex(address: ContractAddress, context: QueryContext): LedgerState;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): LedgerState;
  toString(compact?: boolean): string;
  /**
   * Retrieves the balance of the treasury for a specific token type.
   */
  treasuryBalance(token_type: string): bigint;
  /**
   * How much in minting rewards a recipient, for a specific token type, is
   * owed and can claim.
   */
  unclaimedMints(recipient: string, token_type: string): bigint;
  /**
   * The remaining unminted supply of native tokens.
   */
  readonly unmintedNativeTokenSupply: bigint;
  /**
   * The Zswap part of the ledger state
   */
  readonly zswap: ZswapChainState;
}

/**
 * A single contract call segment
 */
export class ContractCall {
  private constructor();
  toString(compact?: boolean): string;
  /**
   * The address being called
   */
  readonly address: ContractAddress;
  /**
   * The communication commitment of this call
   */
  readonly communicationCommitment: CommunicationCommitment;
  /**
   * The entry point being called
   */
  readonly entryPoint: Uint8Array | string;
  /**
   * The fallible execution stage transcript
   */
  readonly fallibleTranscript: Transcript<AlignedValue> | undefined;
  /**
   * The guaranteed execution stage transcript
   */
  readonly guaranteedTranscript: Transcript<AlignedValue> | undefined;
}

/**
 * A {@link ContractCall} still being assembled
 */
export class ContractCallPrototype {
  /**
   * @param address - The address being called
   * @param entry_point - The entry point being called
   * @param op - The operation expected at this entry point
   * @param guaranteed_public_transcript - The guaranteed transcript computed
   * for this call
   * @param fallible_public_transcript - The fallible transcript computed for
   * this call
   * @param private_transcript_outputs - The private transcript recorded for
   * this call
   * @param input - The input(s) provided to this call
   * @param output - The output(s) computed from this call
   * @param communication_commitment_rand - The communication randomness used
   * for this call
   * @param key_location - An identifier for how the key for this call may be
   * looked up
   */
  constructor(
    address: ContractAddress,
    entry_point: Uint8Array | string,
    op: ContractOperation,
    guaranteed_public_transcript: Transcript<AlignedValue> | undefined,
    fallible_public_transcript: Transcript<AlignedValue> | undefined,
    private_transcript_outputs: AlignedValue[],
    input: AlignedValue,
    output: AlignedValue,
    communication_commitment_rand: CommunicationCommitmentRand,
    key_location: string,
  );
  toString(compact?: boolean): string;
}

/**
 * An atomic collection of {@link ContractAction}s, which may interact
 * with each other
 */
export class ContractCallsPrototype {
  constructor();
  addCall(call: ContractCallPrototype): ContractCallsPrototype;
  addDeploy(deploy: ContractDeploy): ContractCallsPrototype;
  addMaintenanceUpdate(upd: MaintenanceUpdate): ContractCallsPrototype;
  toString(compact?: boolean): string;
}

/**
 * The context against which a transaction is run.
 */
export class TransactionContext {
  /**
   * @param ref_state - A past ledger state that is used as a reference point
   * for 'static' data.
   * @param block_context - Information about the block this transaction is, or
   * will be, contained in.
   * @param whitelist - A list of contracts that are being tracked, or
   * `undefined` to track all contracts.
   */
  constructor(ref_state: LedgerState, block_context: BlockContext, whitelist?: Set<ContractAddress>);
  toString(compact?: boolean): string;
}

/**
 * The result status of applying a transaction.
 * Includes an error message if the transaction failed, or partially failed.
 */
export class TransactionResult {
  private constructor();
  readonly type: 'success' | 'partialSuccess' | 'failure';
  readonly error?: string;
  toString(compact?: boolean): string;
}

/**
 * A single update instruction in a {@link MaintenanceUpdate}.
 */
export type SingleUpdate = ReplaceAuthority | VerifierKeyRemove | VerifierKeyInsert;

/**
 * The version associated with a {@link ContractOperation}
 */
export class ContractOperationVersion {
  constructor(version: 'v2');
  readonly version: 'v2';
  toString(compact?: boolean): string;
}

/**
 * A versioned verifier key to be associated with a {@link ContractOperation}.
 */
export class ContractOperationVersionedVerifierKey {
  constructor(version: 'v2', rawVk: Uint8Array);
  readonly version: 'v2';
  readonly rawVk: Uint8Array;
  toString(compact?: boolean): string;
}

/**
 * An update instruction to replace the current contract maintenance authority
 * with a new one.
 */
export class ReplaceAuthority {
  constructor(authority: ContractMaintenanceAuthority);
  readonly authority: ContractMaintenanceAuthority;
  toString(compact?: boolean): string;
}

/**
 * An update instruction to remove a verifier key of a specific operation and
 * version.
 */
export class VerifierKeyRemove {
  constructor(operation: string | Uint8Array, version: ContractOperationVersion);
  readonly operation: string | Uint8Array;
  readonly version: ContractOperationVersion;
  toString(compact?: boolean): string;
}

/**
 * An update instruction to insert a verifier key at a specific operation and
 * version.
 */
export class VerifierKeyInsert {
  constructor(operation: string | Uint8Array, vk: ContractOperationVersionedVerifierKey);
  readonly operation: string | Uint8Array;
  readonly vk: ContractOperationVersionedVerifierKey;
  toString(compact?: boolean): string;
}

/**
 * A contract maintenance update, updating associated operations, or
 * changing the maintenance authority.
 */
export class MaintenanceUpdate {
  constructor(address: ContractAddress, updates: SingleUpdate[], counter: bigint);
  /**
   * Adds a new signature to this update
   */
  addSignature(idx: bigint, signature: Signature): MaintenanceUpdate;
  toString(compact?: boolean): string;
  /**
   * The raw data any valid signature must be over to approve this update.
   */
  readonly dataToSign: Uint8Array;
  /**
   * The address this deployment will attempt to create
   */
  readonly address: ContractAddress;
  /**
   * The updates to carry out
   */
  readonly updates: SingleUpdate[];
  /**
   * The counter this update is valid against
   */
  readonly counter: bigint;
  /**
   * The signatures on this update
   */
  readonly signatures: [bigint, Signature][];
}

/**
 * A contract deployment segment, instructing the creation of a new contract
 * address, if not already present
 */
export class ContractDeploy {
  /**
   * Creates a deployment for an arbitrary contract state
   *
   * The deployment and its address are randomised.
   */
  constructor(initial_state: ContractState);
  toString(compact?: boolean): string;
  /**
   * The address this deployment will attempt to create
   */
  readonly address: ContractAddress;
  readonly initialState: ContractState;
}

/**
 * A Midnight transaction, consisting a section of {@link
 * ContractAction}s, and a guaranteed and fallible {@link Offer}.
 *
 * The guaranteed section are run first, and fee payment is taken during this
 * part. If it succeeds, the fallible section is also run, and atomically
 * rolled back if it fails.
 */
export class Transaction {
  private constructor();
  /**
   * Type hint that you should use an external proving function, for instance
   * via the proof server.
   */
  static fromUnproven(prove: (unproven: UnprovenTransaction) => Promise<Transaction>, unproven: UnprovenTransaction): Promise<Transaction>;
  /**
   * Erases the proofs contained in this transaction
   */
  eraseProofs(): ProofErasedTransaction;
  /**
   * Tests well-formedness criteria, optionally including transaction balancing
   *
   * @throws If the transaction is not well-formed for any reason
   */
  wellFormed(ref_state: LedgerState, strictness: WellFormedStrictness): void;
  /**
   * Returns the hash associated with this transaction. Due to the ability to
   * merge transactions, this should not be used to watch for a specific
   * transaction.
   */
  transactionHash(): TransactionHash;
  /**
   * Returns the set of identifiers contained within this transaction. Any of
   * these *may* be used to watch for a specific transaction.
   */
  identifiers(): TransactionId[];
  /**
   * Merges this transaction with another
   *
   * @throws If both transactions have contract interactions, or they spend the
   * same coins
   */
  merge(other: Transaction): Transaction;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Transaction;
  /**
   * For given fees, and a given section (guaranteed/fallible), what the
   * surplus or deficit of this transaction in any token type is.
   */
  imbalances(guaranteed: boolean, fees?: bigint): Map<TokenType, bigint>;
  /**
   * The cost of this transaction, in the atomic unit of the base token
   */
  fees(params: LedgerParameters): bigint;
  toString(compact?: boolean): string;
  /**
   * The mint this transaction represents, if applicable
   */
  readonly mint: AuthorizedMint | undefined;
  /**
   * The contract interactions contained in this transaction
   */
  readonly contractCalls: ContractAction[];
  /**
   * The fallible Zswap offer
   */
  readonly fallibleCoins: Offer | undefined;
  /**
   * The guaranteed Zswap offer
   */
  readonly guaranteedCoins: Offer | undefined;
}

/**
 * {@link Transaction}, prior to being proven
 *
 * All "shielded" information in the transaction can still be extracted at this
 * stage!
 */
export class UnprovenTransaction {
  /**
   * Creates the transaction from guaranteed/fallible {@link UnprovenOffer}s,
   * and a {@link ContractCallsPrototype}.
   */
  constructor(guaranteed: UnprovenOffer, fallible?: UnprovenOffer, calls?: ContractCallsPrototype);
  /**
   * Creates a minting claim transaction, the funds claimed must have been
   * legitimately minted previously.
   */
  static fromMint(mint: UnprovenAuthorizedMint): UnprovenTransaction;
  /**
   * Erases the proofs contained in this transaction
   */
  eraseProofs(): ProofErasedTransaction;
  /**
   * Returns the set of identifiers contained within this transaction. Any of
   * these *may* be used to watch for a specific transaction.
   */
  identifiers(): TransactionId[];
  /**
   * Merges this transaction with another
   *
   * @throws If both transactions have contract interactions, or they spend the
   * same coins
   */
  merge(other: UnprovenTransaction): UnprovenTransaction;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenTransaction;
  /**
   * For given fees, and a given section (guaranteed/fallible), what the
   * surplus or deficit of this transaction in any token type is.
   */
  imbalances(guaranteed: boolean, fees?: bigint): Map<TokenType, bigint>;
  toString(compact?: boolean): string;
  /**
   * The mint this transaction represents, if applicable
   */
  readonly mint: UnprovenAuthorizedMint | undefined;
  /**
   * The contract interactions contained in this transaction
   */
  readonly contractCalls: ContractAction[];
  /**
   * The fallible Zswap offer
   */
  readonly fallibleCoins: UnprovenOffer | undefined;
  /**
   * The guaranteed Zswap offer
   */
  readonly guaranteedCoins: UnprovenOffer | undefined;
}

/**
 * {@link Transaction}, with all proof information erased
 *
 * Primarily for use in testing, or handling data known to be correct from
 * external information
 */
export class ProofErasedTransaction {
  private constructor();
  /**
   * Tests well-formedness criteria, optionally including transaction balancing
   *
   * For obvious reasons, doesn't check proofs
   *
   * @throws If the transaction is not well-formed for any reason
   */
  wellFormed(ref_state: LedgerState, strictness: WellFormedStrictness): void;
  /**
   * Returns the set of identifiers contained within this transaction. Any of
   * these *may* be used to watch for a specific transaction.
   */
  identifiers(): TransactionId[];
  /**
   * Merges this transaction with another
   *
   * @throws If both transactions have contract interactions, or they spend the
   * same coins
   */
  merge(other: ProofErasedTransaction): ProofErasedTransaction;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedTransaction;
  /**
   * For given fees, and a given section (guaranteed/fallible), what the
   * surplus or deficit of this transaction in any token type is.
   */
  imbalances(guaranteed: boolean, fees?: bigint): Map<TokenType, bigint>;
  /**
   * The cost of this transaction, in the atomic unit of the base token
   */
  fees(params: LedgerParameters): bigint;
  toString(compact?: boolean): string;
  /**
   * The mint this transaction represents, if applicable
   */
  readonly mint: ProofErasedAuthorizedMint | undefined;
  /**
   * The contract interactions contained in this transaction
   */
  readonly contractCalls: ContractAction[];
  /**
   * The fallible Zswap offer
   */
  readonly fallibleCoins: ProofErasedOffer | undefined;
  /**
   * The guaranteed Zswap offer
   */
  readonly guaranteedCoins: ProofErasedOffer | undefined;
}

/**
 * A transcript prior to partitioning, consisting of the context to run it in, the program that
 * will make up the transcript, and optionally a communication commitment to bind calls together.
 */
export class PreTranscript {
  constructor(context: QueryContext, program: Op<AlignedValue>[], comm_comm?: CommunicationCommitment);
  toString(compact?: boolean): string;
}

/**
 * Computes the communication commitment corresponding to an input/output pair and randomness.
 */
export function communicationCommitment(input: AlignedValue, output: AlignedValue, rand: CommunicationCommitmentRand): CommunicationCommitment;

/**
 * Finalizes a set of programs against their initial contexts,
 * resulting in guaranteed and fallible {@link Transcript}s, optimally
 * allocated, and heuristically covered for gas fees.
 */
export function partitionTranscripts(calls: PreTranscript[], params: LedgerParameters): [Transcript<AlignedValue> | undefined, Transcript<AlignedValue> | undefined][];

// From zswap.d.ts
/**
 * The hash of a transaction, as a hex-encoded 256-bit bytestring
 */
export type TransactionHash = string;
/**
 * A transaction identifier, used to index merged transactions
 */
export type TransactionId = string;
/**
 * An encryption public key, used to inform users of new coins sent to them
 */
export type EncPublicKey = string;

/**
 * Samples a dummy user coin public key, for use in testing
 */
export function sampleCoinPublicKey(): CoinPublicKey;
/**
 * Samples a dummy user encryption public key, for use in testing
 */
export function sampleEncryptionPublicKey(): EncPublicKey;
/**
 * Creates a new {@link CoinInfo}, sampling a uniform nonce
 */
export function createCoinInfo(type_: TokenType, value: bigint): CoinInfo;
/**
 * The base/system token type
 */
export function nativeToken(): TokenType;

/**
 * Calculate commitment of a coin owned by a user
 */
export function coinCommitment(coin: CoinInfo, coinPublicKey: CoinPublicKey): CoinCommitment;

/**
 * Calculate nullifier of a coin owned by a user
 */
export function coinNullifier(coin: CoinInfo, coinSecretKey: CoinSecretKey): Nullifier;

/**
 * Parameters used by the Midnight ledger, including transaction fees and
 * bounds
 */
export class LedgerParameters {
  private constructor();
  /**
   * A dummy set of testing parameters
   */
  static dummyParameters(): LedgerParameters;
  /**
   * The cost model used for transaction fees contained in these parameters
   */
  readonly transactionCostModel: TransactionCostModel;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): LedgerParameters;
  toString(compact?: boolean): string;
}

export class TransactionCostModel {
  private constructor();
  /**
   * A dummy cost model, for use in testing
   */
  static dummyTransactionCostModel(): TransactionCostModel;
  /**
   * The increase in fees to expect from adding a new input to a transaction
   */
  readonly inputFeeOverhead: bigint;
  /**
   * The increase in fees to expect from adding a new output to a transaction
   */
  readonly outputFeeOverhead: bigint;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): TransactionCostModel;
  toString(compact?: boolean): string;
}


/**
 * A compact delta on the coin commitments Merkle tree, used to keep local
 * spending trees in sync with the global state without requiring receiving all
 * transactions.
 */
export class MerkleTreeCollapsedUpdate {
  /**
   * Create a new compact update from a non-compact state, and inclusive
   * `start` and `end` indices
   *
   * @throws If the indices are out-of-bounds for the state, or `end < start`
   */
  constructor(state: ZswapChainState, start: bigint, end: bigint);
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): MerkleTreeCollapsedUpdate;
  toString(compact?: boolean): string;
}

/**
 * Holds the encryption secret key of a user, which may be used to determine if
 * a given offer contains outputs addressed to this user
 */
export class EncryptionSecretKey {
  private constructor();
  test(offer: Offer): boolean;
  yesIKnowTheSecurityImplicationsOfThis_serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): EncryptionSecretKey
}

export class SecretKeys {
  private constructor();
  /**
   * Derives secret keys from a 32-byte seed
   */
  static fromSeed(seed: Uint8Array): SecretKeys;

  /**
   * Derives secret keys from a 32-byte seed using deprecated implementation.
   * Use only for compatibility purposes
   */
  static fromSeedRng(seed: Uint8Array): SecretKeys;

  readonly coinPublicKey: CoinPublicKey;
  readonly coinSecretKey: CoinSecretKey
  readonly encryptionPublicKey: EncPublicKey;
  readonly encryptionSecretKey: EncryptionSecretKey;
}

/**
 * The on-chain state of Zswap, consisting of a Merkle tree of coin
 * commitments, a set of nullifiers, an index into the Merkle tree, and a set
 * of valid past Merkle tree roots
 */
export class ZswapChainState {
  constructor();
  serialize(netid: NetworkId): Uint8Array;
  /**
   * The first free index in the coin commitment tree
   */
  readonly firstFree: bigint;
  static deserialize(raw: Uint8Array, netid: NetworkId): ZswapChainState;
  /**
   * Given a whole ledger serialized state, deserialize only the Zswap portion
   */
  static deserializeFromLedgerState(raw: Uint8Array, netid: NetworkId): ZswapChainState;
  /**
   * Try to apply an {@link Offer} to the state, returning the updated state
   * and a map on newly inserted coin commitments to their inserted indices.
   *
   * @param whitelist - A set of contract addresses that are of interest. If
   * set, *only* these addresses are tracked, and all other information is
   * discarded.
   */
  tryApply(offer: Offer, whitelist?: Set<ContractAddress>): [ZswapChainState, Map<CoinCommitment, bigint>];
  /**
   * {@link tryApply} for {@link ProofErasedOffer}s
   */
  tryApplyProofErased(offer: ProofErasedOffer, whitelist?: Set<ContractAddress>): [ZswapChainState, Map<CoinCommitment, bigint>];
  toString(compact?: boolean): string;
}

/**
 * The local state of a user/wallet, consisting of a set
 * of unspent coins
 *
 * It also keeps track of coins that are in-flight, either expecting to spend
 * or expecting to receive, and a local copy of the global coin commitment
 * Merkle tree to generate proofs against.
 */
export class LocalState {
  /**
   * Creates a new, empty state
   */
  constructor();

  /**
   * Applies a collapsed Merkle tree update to the current local state, fast
   * forwarding through the indices included in it, if it is a correct update.
   *
   * The general flow for usage if Alice is in state A, and wants to ask Bob how to reach the new state B, is:
   *  - Find where she left off – what's her firstFree?
   *  - Find out where she's going – ask for Bob's firstFree.
   *  - Find what contents she does care about – ask Bob for the filtered
   *    entries she want to include proper in her tree.
   *  - In order, of Merkle tree indicies:
   *    - Insert (with `apply` offers Alice cares about).
   *    - Skip (with this method) sections Alice does not care about, obtaining
   *      the collapsed update covering the gap from Bob.
   * Note that `firstFree` is not included in the tree itself, and both ends of
   * updates *are* included.
   */
  applyCollapsedUpdate(update: MerkleTreeCollapsedUpdate): LocalState;
  /**
   * Locally marks an offer as failed, allowing inputs used in it to be
   * spendable once more.
   */
  applyFailed(offer: Offer): LocalState;
  /**
   * Locally marks an proof-erased offer as failed, allowing inputs used in it
   * to be spendable once more.
   */
  applyFailedProofErased(offer: ProofErasedOffer): LocalState;
  /**
   * Locally applies an offer to the current state, returning the updated state
   */
  apply(secretKeys: SecretKeys, offer: Offer): LocalState;
  /**
   * Locally applies a proof-erased offer to the current state, returning the
   * updated state
   */
  applyProofErased(secretKeys: SecretKeys, offer: ProofErasedOffer): LocalState;
  /**
   * Locally applies a transaction to the current state, returning the updated
   * state
   *
   * @param res - The result type of applying this transaction against the
   * ledger state
   */
  applyTx(secretKeys: SecretKeys, tx: Transaction, res: 'success' | 'partialSuccess' | 'failure'): LocalState;
  /**
   * Locally applies a proof-erased transaction to the current state, returning
   * the updated state
   *
   * @param res - The result type of applying this transaction against the
   * ledger state
   */
  applyProofErasedTx(secretKeys: SecretKeys, tx: ProofErasedTransaction, res: 'success' | 'partialSuccess' | 'failure'): LocalState;
  /**
   * Locally applies a system transaction to the current state, returning the
   * updated state
   */
  applySystemTx(secretKeys: SecretKeys, tx: SystemTransaction): LocalState;
  /**
   * Initiates a new spend of a specific coin, outputting the corresponding
   * {@link UnprovenInput}, and the updated state marking this coin as
   * in-flight.
   */
  spend(secretKeys: SecretKeys, coin: QualifiedCoinInfo, segment: number): [LocalState, UnprovenInput];
  /**
   * Initiates a new spend of a new-yet-received output, outputting the
   * corresponding {@link UnprovenTransient}, and the updated state marking
   * this coin as in-flight.
   */
  spendFromOutput(secretKeys: SecretKeys, coin: QualifiedCoinInfo, segment: number, output: UnprovenOutput): [LocalState, UnprovenTransient];
  /**
   * Adds a coin to the list of coins that are expected to be received
   *
   * This should be used if an output is creating a coin for this wallet, which
   * does not contain a ciphertext to detect it. In this case, the wallet must
   * know the commitment ahead of time to notice the receipt.
   */
  watchFor(coinPublicKey: CoinPublicKey, coin: CoinInfo): LocalState;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): LocalState;
  toString(compact?: boolean): string;
  /**
   * The set of *spendable* coins of this wallet
   */
  readonly coins: Set<QualifiedCoinInfo>;
  /**
   * The first free index in the internal coin commitments Merkle tree.
   * This may be used to identify which merkle tree updates are necessary.
   */
  readonly firstFree: bigint;
  /**
   * The outputs that this wallet is expecting to receive in the future
   */
  readonly pendingOutputs: Map<CoinCommitment, CoinInfo>;
  /**
   * The spends that this wallet is expecting to be finalized on-chain in the
   * future
   */
  readonly pendingSpends: Map<Nullifier, QualifiedCoinInfo>;
}

/**
 * A shielded transaction input
 */
export class Input {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Input;
  toString(compact?: boolean): string;
  /**
   * The contract address receiving the input, if the sender is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the input
   */
  readonly nullifier: Nullifier;
}

/**
 * A {@link Input}, before being proven
 *
 * All "shielded" information in the input can still be extracted at this
 * stage!
 */
export class UnprovenInput {
  private constructor();
  /**
   * Creates a new input, spending a specific coin from a smart contract,
   * against a state which contains this coin.
   *
   * Note that inputs created in this way *also* need to be authorized by the
   * contract
   */
  static newContractOwned(coin: QualifiedCoinInfo, segment: number, contract: ContractAddress, state: ZswapChainState): UnprovenInput;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenInput;
  toString(compact?: boolean): string;
  /**
   * The contract address receiving the input, if the sender is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the input
   */
  readonly nullifier: Nullifier;
}

/**
 * A {@link Input}, with all proof information erased
 *
 * Primarily for use in testing, or handling data known to be correct from
 * external information
 */
export class ProofErasedInput {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedInput;
  toString(compact?: boolean): string;
  /**
   * The contract address receiving the input, if the sender is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the input
   */
  readonly nullifier: Nullifier;
}

/**
 * A shielded transaction output
 */
export class Output {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Output;
  toString(compact?: boolean): string;
  /**
   * The commitment of the output
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address receiving the output, if the recipient is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
}

/**
 * An {@link Output} before being proven
 *
 * All "shielded" information in the output can still be extracted at this
 * stage!
 */
export class UnprovenOutput {
  private constructor();
  /**
   * Creates a new output, targeted to a user's coin public key.
   *
   * Optionally the output contains a ciphertext encrypted to the user's
   * encryption public key, which may be omitted *only* if the {@link CoinInfo}
   * is transferred to the recipient another way
   */
  static new(coin: CoinInfo, segment: number, target_cpk: CoinPublicKey, target_epk: EncPublicKey): UnprovenOutput;
  /**
   * Creates a new output, targeted to a smart contract
   *
   * A contract must *also* explicitly receive a coin created in this way for
   * the output to be valid
   */
  static newContractOwned(coin: CoinInfo, segment: number, contract: ContractAddress): UnprovenOutput;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenOutput;
  toString(compact?: boolean): string;
  /**
   * The commitment of the output
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address receiving the output, if the recipient is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
}

/**
 * An {@link Output} with all proof information erased
 *
 * Primarily for use in testing, or handling data known to be correct from
 * external information
 */
export class ProofErasedOutput {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedOutput;
  toString(compact?: boolean): string;
  /**
   * The commitment of the output
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address receiving the output, if the recipient is a contract
   */
  readonly contractAddress: ContractAddress | undefined;
}

/**
 * A shielded "transient"; an output that is immediately spent within the same
 * transaction
 */
export class Transient {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Transient;
  toString(compact?: boolean): string;
  /**
   * The commitment of the transient
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address creating the transient, if applicable
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the transient
   */
  readonly nullifier: Nullifier;
}

/**
 * A {@link Transient}, before being proven
 *
 * All "shielded" information in the transient can still be extracted at this
 * stage!
 */
export class UnprovenTransient {
  private constructor();
  /**
   * Creates a new contract-owned transient, from a given output and its coin.
   *
   * The {@link QualifiedCoinInfo} should have an `mt_index` of `0`
   */
  static newFromContractOwnedOutput(coin: QualifiedCoinInfo, segment: number, output: UnprovenOutput): UnprovenTransient;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenTransient;
  toString(compact?: boolean): string;
  /**
   * The commitment of the transient
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address creating the transient, if applicable
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the transient
   */
  readonly nullifier: Nullifier;
}

/**
 * A {@link Transient}, with all proof information erased
 *
 * Primarily for use in testing, or handling data known to be correct from
 * external information
 */
export class ProofErasedTransient {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedTransient;
  toString(compact?: boolean): string;
  /**
   * The commitment of the transient
   */
  readonly commitment: CoinCommitment;
  /**
   * The contract address creating the transient, if applicable
   */
  readonly contractAddress: ContractAddress | undefined;
  /**
   * The nullifier of the transient
   */
  readonly nullifier: Nullifier;
}

/**
 * A request to mint a coin, authorized by the mint's recipient
 */
export class AuthorizedMint {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): AuthorizedMint;
  erase_proof(): ProofErasedAuthorizedMint;
  /**
   * The coin to be minted
   */
  readonly coin: CoinInfo;
  /**
   * The recipient of this mint
   */
  readonly recipient: string;
  toString(compact?: boolean): string;
}

/**
 * A request to mint a coin, authorized by the mint's recipient, without the
 * proof for the authorization being generated
 */
export class UnprovenAuthorizedMint {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenAuthorizedMint;
  erase_proof(): ProofErasedAuthorizedMint;
  /**
   * The coin to be minted
   */
  readonly coin: CoinInfo;
  /**
   * The recipient of this mint
   */
  readonly recipient: string;
  toString(compact?: boolean): string;
}

/**
 * A request to mint a coin, authorized by the mint's recipient, with the
 * authorizing proof having been erased
 */
export class ProofErasedAuthorizedMint {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedAuthorizedMint;
  /**
   * The coin to be minted
   */
  readonly coin: CoinInfo;
  /**
   * The recipient of this mint
   */
  readonly recipient: string;
  toString(compact?: boolean): string;
}

/**
 * A full Zswap offer; the zswap part of a transaction
 *
 * Consists of sets of {@link Input}s, {@link Output}s, and {@link Transient}s,
 * as well as a {@link deltas} vector of the transaction value
 */
export class Offer {
  private constructor();
  /**
   * Combine this offer with another
   */
  merge(other: Offer): Offer;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Offer;
  toString(compact?: boolean): string;
  /**
   * The value of this offer for each token type; note that this may be
   * negative
   *
   * This is input coin values - output coin values, for value vectors
   */
  readonly deltas: Map<TokenType, bigint>;
  /**
   * The inputs this offer is composed of
   */
  readonly inputs: Input[];
  /**
   * The outputs this offer is composed of
   */
  readonly outputs: Output[];
  /**
   * The transients this offer is composed of
   */
  readonly transient: Transient[];
}

/**
 * A {@link Offer}, prior to being proven
 *
 * All "shielded" information in the offer can still be extracted at this
 * stage!
 */
export class UnprovenOffer {
  constructor();
  /**
   * Creates a singleton offer, from an {@link UnprovenInput} and its value
   * vector
   */
  static fromInput(input: UnprovenInput, type_: TokenType, value: bigint): UnprovenOffer;
  /**
   * Creates a singleton offer, from an {@link UnprovenOutput} and its value
   * vector
   */
  static fromOutput(output: UnprovenOutput, type_: TokenType, value: bigint): UnprovenOffer;
  /**
   * Creates a singleton offer, from an {@link UnprovenTransient}
   */
  static fromTransient(transient: UnprovenTransient): UnprovenOffer;
  /**
   * Combine this offer with another
   */
  merge(other: UnprovenOffer): UnprovenOffer;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): UnprovenOffer;
  toString(compact?: boolean): string;
  /**
   * The value of this offer for each token type; note that this may be
   * negative
   *
   * This is input coin values - output coin values, for value vectors
   */
  readonly deltas: Map<TokenType, bigint>;
  /**
   * The inputs this offer is composed of
   */
  readonly inputs: UnprovenInput[];
  /**
   * The outputs this offer is composed of
   */
  readonly outputs: UnprovenOutput[];
  /**
   * The transients this offer is composed of
   */
  readonly transient: UnprovenTransient[];
}

/**
 * An {@link Offer}, with all proof information erased
 *
 * Primarily for use in testing, or handling data known to be correct from
 * external information
 */
export class ProofErasedOffer {
  private constructor();
  merge(other: ProofErasedOffer): ProofErasedOffer;
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): ProofErasedOffer;
  toString(compact?: boolean): string;
  /**
   * The value of this offer for each token type; note that this may be
   * negative
   *
   * This is input coin values - output coin values, for value vectors
   */
  readonly deltas: Map<TokenType, bigint>;
  /**
   * The inputs this offer is composed of
   */
  readonly inputs: ProofErasedInput[];
  /**
   * The outputs this offer is composed of
   */
  readonly outputs: ProofErasedOutput[];
  /**
   * The transients this offer is composed of
   */
  readonly transient: ProofErasedTransient[];
}

/**
 * A priviledged transaction issued by the system.
 */
export class SystemTransaction {
  private constructor();
  serialize(netid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, netid: NetworkId): Transaction;
  toString(compact?: boolean): string;
}
// From onchain-runtime.d.ts
/**
 * An onchain data value, in field-aligned binary format.
 */
export type Value = Array<Uint8Array>;
/**
 * The alignment of an onchain field-aligned binary data value.
 */
export type Alignment = AlignmentSegment[];
/**
 * A segment in a larger {@link Alignment}.
 */
export type AlignmentSegment = { tag: "option", value: Alignment[] } | { tag: "atom", value: AlignmentAtom };
/**
 * A atom in a larger {@link Alignment}.
 */
export type AlignmentAtom = { tag: "compress" } | { tag: "field" } | { tag: "bytes", length: number };
/**
 * An onchain data value, in field-aligned binary format, annotated with its
 * alignment.
 */
export type AlignedValue = { value: Value, alignment: Alignment };
/**
 * A Zswap nullifier, as a hex-encoded 256-bit bitstring
 */
export type Nullifier = string;
/**
 * A Zswap coin commitment, as a hex-encoded 256-bit bitstring
 */
export type CoinCommitment = string;
/**
 * A contract address, as a hex-encoded 35-byte string
 */
export type ContractAddress = string;
/**
 * A token type (or color), as a hex-encoded 35-byte string
 */
export type TokenType = string;
/**
 * A token domain seperator, the pre-stage of `TokenType`, as 32-byte bytearray
 */
export type DomainSeperator = Uint8Array;
/**
 * A user public key capable of receiving Zswap coins, as a hex-encoded 35-byte
 * string
 */
export type CoinPublicKey = string;
/**
 * A user secret key capable of sending Zswap coins, as a hex-encoded 35-byte
 * string
 */
export type CoinSecretKey = string;
/**
 * A Zswap nonce, as a hex-encoded 256-bit string
 */
export type Nonce = string;
/**
 * A hex-encoded signature BIP-340 verifying key, with a 3-byte version prefix
 */
export type SignatureVerifyingKey = string;
/**
 * A hex-encoded signature BIP-340 signing key, with a 3-byte version prefix
 */
export type SigningKey = string;
/**
 * A hex-encoded signature BIP-340 signature, with a 3-byte version prefix
 */
export type Signature = string;
/**
 * An internal encoding of a value of the proof systems scalar field
 */
export type Fr = Uint8Array;
/**
 * Information required to create a new coin, alongside details about the
 * recipient
 */
export type CoinInfo = {
  /**
   * The coin's type, identifying the currency it represents
   */
  type: TokenType,
  /**
   * The coin's randomness, preventing it from colliding with other coins
   */
  nonce: Nonce,
  /**
   * The coin's value, in atomic units dependent on the currency
   *
   * Bounded to be a non-negative 64-bit integer
   */
  value: bigint,
};
/**
 * Information required to spend an existing coin, alongside authorization of
 * the owner
 */
export type QualifiedCoinInfo = {
  /**
   * The coin's type, identifying the currency it represents
   */
  type: TokenType,
  /**
   * The coin's randomness, preventing it from colliding with other coins
   */
  nonce: Nonce,
  /**
   * The coin's value, in atomic units dependent on the currency
   *
   * Bounded to be a non-negative 64-bit integer
   */
  value: bigint,
  /**
   * The coin's location in the chain's Merkle tree of coin commitments
   *
   * Bounded to be a non-negative 64-bit integer
   */
  mt_index: bigint,
};

/**
 * A key used to index into an array or map in the onchain VM
 */
export type Key = { tag: "value", value: AlignedValue } | { tag: "stack" };
/**
 * An individual operation in the onchain VM
 *
 * @typeParam R - `null` or {@link AlignedValue}, for gathering and verifying
 * mode respectively
 */
export type Op<R> = { noop: { n: number } } |
                    "lt" |
                    "eq" |
                    "type" |
                    "size" |
                    "new" |
                    "and" |
                    "or" |
                    "neg" |
                    "log" |
                    "root" |
                    "pop" |
                    { popeq: { cached: boolean, result: R } } |
                    { addi: { immediate: number } } |
                    { subi: { immediate: number } } |
                    { push: { storage: boolean, value: EncodedStateValue } } |
                    { branch: { skip: number } } |
                    { jmp: { skip: number } } |
                    "add" |
                    "sub" |
                    { concat: { cached: boolean, n: number } } |
                    "member" |
                    { rem: { cached: boolean } } |
                    { dup: { n: number } } |
                    { swap: { n: number } } |
                    { idx: { cached: boolean, pushPath: boolean, path: Key[] } } |
                    { ins: { cached: boolean, n: number } } |
                    "ckpt";
/**
 * An individual result of observing the results of a non-verifying VM program
 * execution
 */
export type GatherResult = { tag: "read", content: AlignedValue } |
                           { tag: "log", content: EncodedStateValue };
/**
 * An alternative encoding of {@link StateValue} for use in {@link Op} for
 * technical reasons
 */
export type EncodedStateValue = { tag: "null" } |
                                { tag: "cell", content: AlignedValue } |
                                { tag: "map", content: Map<AlignedValue, EncodedStateValue> } |
                                { tag: "array", content: EncodedStateValue[] } |
                                { tag: "boundedMerkleTree", content: [number, Map<bigint, [Uint8Array, undefined]>] };
/**
 * A transcript of operations, to be recorded in a transaction
 */
export type Transcript<R> = {
  /**
   * The execution budget for this transcript, which {@link program} must not
   * exceed
   */
  gas: bigint,
  /**
   * The effects of the transcript, which are checked before execution, and
   * must match those constructed by {@link program}
   */
  effects: Effects,
  /**
   * The sequence of operations that this transcript captured
   */
  program: Op<R>[],
};
/**
 * The context information about a block available inside the VM
 */
export type BlockContext = {
  /**
   * The seconds since the UNIX epoch that have elapsed
   */
  secondsSinceEpoch: bigint,
  /**
   * The maximum error on {@link secondsSinceEpoch} that should occur, as a
   * positive seconds value
   */
  secondsSinceEpochErr: number,
  /**
   * The hash of the block prior to this transaction, as a hex-encoded string
   */
  blockHash: string,
};
/**
 * The contract-external effects of a transcript.
 */
export type Effects = {
  /**
   * The nullifiers (spends) this contract call requires
   */
  claimedNullifiers: Nullifier[],
  /**
   * The coin commitments (outputs) this contract call requires, as coins
   * received
   */
  claimedReceives: CoinCommitment[],
  /**
   * The coin commitments (outputs) this contract call requires, as coins
   * sent
   */
  claimedSpends: CoinCommitment[],
  /**
   * The contracts called from this contract. The values are, in order:
   *
   * - The sequence number of this call
   * - The contract being called
   * - The entry point being called
   * - The communications commitment
   */
  claimedContractCalls: Array<[bigint, ContractAddress, string, Fr]>,
  /**
   * The tokens minted in this call, as a map from hex-encoded 256-bit domain
   * separators to non-negative 64-bit integers.
   */
  mints: Map<string, bigint>,
};

/**
 * The network currently being targeted
 */
export enum NetworkId {
  /**
   * A local test network
   */
  Undeployed = 0,
  /**
   * A developer network, not guaranteed to be persistent
   */
  DevNet = 1,
  /**
   * A persistent testnet
   */
  TestNet = 2,
  /**
   * The Midnight mainnet
   */
  MainNet = 3,
}
/**
 * A hex-encoded commitment of data shared between two contracts in a call
 */
export type CommunicationCommitment = string;
/**
 * The hex-encoded randomness to {@link CommunicationCommitment}
 */
export type CommunicationCommitmentRand = string;

/**
 * Samples a new {@link CommunicationCommitmentRand} uniformly
 */
export function communicationCommitmentRandomness(): CommunicationCommitmentRand;

/**
 * Computes the communication commitment corresponding to an input/output pair and randomness.
 */
export function communicationCommitment(input: AlignedValue, output: AlignedValue, rand: CommunicationCommitmentRand): CommunicationCommitment;

/**
 * Computes the (hex-encoded) hash of a given contract entry point. Used in
 * composable contracts to reference the called contract's entry point ID
 * in-circuit.
 */
export function entryPointHash(entryPoint: string | Uint8Array): string;

/**
 * Randomly samples a {@link SigningKey}.
 */
export function sampleSigningKey(): SigningKey;
/**
 * Signs arbitrary data with the given signing key.
 *
 * WARNING: Do not expose access to this function for valuable keys for data
 * that is not strictly controlled!
 */
export function signData(key: SigningKey, data: Uint8Array): Signature;
/**
 * Returns the verifying key for a given signing key
 */
export function signatureVerifyingKey(sk: SigningKey): SignatureVerifyingKey;
/**
 * Verifies if a signature is correct
 */
export function verifySignature(vk: SignatureVerifyingKey, data: Uint8Array, signature: Signature): boolean;
/**
 * Encode a {@link TokenType} into a `Uint8Array` for use in Compact's
 * `TokenType` type
 */
export function encodeTokenType(tt: TokenType): Uint8Array;
/**
 * Decode a {@link TokenType} from a `Uint8Array` originating from Compact's
 * `TokenType` type
 */
export function decodeTokenType(tt: Uint8Array): TokenType;
/**
 * Encode a {@link ContractAddress} into a `Uint8Array` for use in Compact's
 * `ContractAddress` type
 */
export function encodeContractAddress(addr: ContractAddress): Uint8Array;
/**
 * Decode a {@link ContractAddress} from a `Uint8Array` originating from
 * Compact's `ContractAddress` type
 */
export function decodeContractAddress(addr: Uint8Array): ContractAddress;
/**
 * Encode a {@link CoinPublicKey} into a `Uint8Array` for use in Compact's
 * `CoinPublicKey` type
 */
export function encodeCoinPublicKey(pk: CoinPublicKey): Uint8Array;
/**
 * Decode a {@link CoinPublicKey} from a `Uint8Array` originating from Compact's
 * `CoinPublicKey` type
 */
export function decodeCoinPublicKey(pk: Uint8Array): CoinPublicKey;
/**
 * Encode a {@link CoinInfo} into a Compact's `CoinInfo` TypeScript
 * representation
 */
export function encodeCoinInfo(coin: CoinInfo): { color: Uint8Array, nonce: Uint8Array, value: bigint };
/**
 * Encode a {@link QualifiedCoinInfo} into a Compact's `QualifiedCoinInfo`
 * TypeScript representation
 */
export function encodeQualifiedCoinInfo(coin: QualifiedCoinInfo): { color: Uint8Array, nonce: Uint8Array, value: bigint, mt_index: bigint };
/**
 * Decode a {@link CoinInfo} from Compact's `CoinInfo` TypeScript representation
 */
export function decodeCoinInfo(coin: { color: Uint8Array, nonce: Uint8Array, value: bigint }): CoinInfo;
/**
 * Decode a {@link QualifiedCoinInfo} from Compact's `QualifiedCoinInfo`
 * TypeScript representation
 */
export function decodeQualifiedCoinInfo(coin: { color: Uint8Array, nonce: Uint8Array, value: bigint, mt_index: bigint }): QualifiedCoinInfo;
/**
 * Derives the {@link TokenType} associated with a particular
 * {@link DomainSeperator} and contract.
 */
export function tokenType(domain_sep: DomainSeperator, contract: ContractAddress): TokenType;
/**
 * Samples a uniform contract address, for use in testing
 */
export function sampleContractAddress(): ContractAddress;
/**
 * Samples a uniform token type, for use in testing
 */
export function sampleTokenType(): TokenType;
/**
 * A sample contract address, guaranteed to be the same for a given network ID
 * for use in testing
 */
export function dummyContractAddress(): string;
/**
 * Internal implementation of the coin commitment primitive.
 * @internal
 */
export function coinCommitment(coin: AlignedValue, recipient: AlignedValue): AlignedValue;
/**
 * Internal implementation of the Merkle tree leaf hash primitive.
 * @internal
 */
export function leafHash(value: AlignedValue): AlignedValue;
/**
 * Internal implementation of the max aligned size primitive.
 * @internal
 */
export function maxAlignedSize(alignment: Alignment): bigint;
/**
 * Returns the maximum representable value in the proof systems scalar field
 * (that is, 1 less than the prime modulus)
 */
export function maxField(): bigint;
/**
 * Internal implementation of proof dry runs.
 * @internal
 * @throws If the proof would not hold
 */
export function checkProofData(zkir: string, input: AlignedValue, output: AlignedValue, public_transcript: Op<AlignedValue>[], private_transcript_outputs: AlignedValue[]): void;
/**
 * Takes a bigint modulus the proof systems scalar field
 */
export function bigIntModFr(x: bigint): bigint;
/**
 * Internal conversion between field-aligned binary values and bigints within
 * the scalar field
 * @internal
 * @throws If the value does not encode a field element
 */
export function valueToBigInt(x: Value): bigint;
/**
 * Internal conversion between bigints and their field-aligned binary
 * representation
 * @internal
 */
export function bigIntToValue(x: bigint): Value;
/**
 * Internal implementation of the transient hash primitive
 * @internal
 * @throws If {@link val} does not have alignment {@link align}
 */
export function transientHash(align: Alignment, val: Value): Value;
/**
 * Internal implementation of the transient commitment primitive
 * @internal
 * @throws If {@link val} does not have alignment {@link align}, or
 * {@link opening} does not encode a field element
 */
export function transientCommit(align: Alignment, val: Value, opening: Value): Value;
/**
 * Internal implementation of the persistent hash primitive
 * @internal
 * @throws If {@link val} does not have alignment {@link align}, or any
 * component has a compress alignment
 */
export function persistentHash(align: Alignment, val: Value): Value;
/**
 * Internal implementation of the persistent commitment primitive
 * @internal
 * @throws If {@link val} does not have alignment {@link align},
 * {@link opening} does not encode a 32-byte bytestring, or any component has a
 * compress alignment
 */
export function persistentCommit(align: Alignment, val: Value, opening: Value): Value;
/**
 * Internal implementation of the degrade to transient primitive
 * @internal
 * @throws If {@link persistent} does not encode a 32-byte bytestring
 */
export function degradeToTransient(persistent: Value): Value;
/**
 * Internal implementation of the upgrade from transient primitive
 * @internal
 * @throws If {@link transient} does not encode a field element
 */
export function upgradeFromTransient(transient: Value): Value;
/**
 * Internal implementation of the hash to curve primitive
 * @internal
 * @throws If {@link val} does not have alignment {@link align}
 */
export function hashToCurve(align: Alignment, val: Value): Value;
/**
 * Internal implementation of the elliptic curve addition primitive
 * @internal
 * @throws If either input does not encode an elliptic curve point
 */
export function ecAdd(a: Value, b: Value): Value;
/**
 * Internal implementation of the elliptic curve multiplication primitive
 * @internal
 * @throws If {@link a} does not encode an elliptic curve point or {@link b}
 * does not encode a field element
 */
export function ecMul(a: Value, b: Value): Value;
/**
 * Internal implementation of the elliptic curve generator multiplication
 * primitive
 * @internal
 * @throws if {@link val} does not encode a field element
 */
export function ecMulGenerator(val: Value): Value;
/**
 * Runs a VM program against an initial stack, with an optional gas limit
 */
export function runProgram(initial: VmStack, ops: Op<null>[], cost_model: CostModel, gas_limit?: bigint): VmResults;

/**
 * An individual operation, or entry point of a contract, consisting primarily
 * of a ZK verifier keys, potentially for different versions of the proving
 * system.
 *
 * Only the latest available version is exposed to this API.
 *
 * Note that the serialized form of the key is checked on initialization
 */
export class ContractOperation {
  constructor();
  verifierKey: Uint8Array;
  serialize(networkid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, networkid: NetworkId): ContractOperation;
  toString(compact?: boolean): string;
}

/**
 * A committee permitted to make changes to this contract. If a threshold of
 * the public keys in this committee sign off, they can change the rules of
 * this contract, or recompile it for a new version.
 *
 * If the threshold is greater than the number of committee members, it is
 * impossible for them to sign anything.
 */
export class ContractMaintenanceAuthority {
  /**
   * Constructs a new authority from its components
   *
   * If not supplied, `counter` will default to `0n`. Values should be
   * non-negative, and at most 2^32 - 1.
   *
   * At deployment, `counter` must be `0n`, and any subsequent update should
   * set counter to exactly one greater than the current value.
   */
  constructor(committee: Array<SignatureVerifyingKey>, threshold: number, counter?: bigint);
  /**
   * The committee public keys
   */
  readonly committee: Array<SignatureVerifyingKey>;
  /**
   * How many keys must sign rule changes
   */
  readonly threshold: number;
  /**
   * The replay protection counter
   */
  readonly counter: bigint;
  serialize(networkid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, networkid: NetworkId): ContractState;
  toString(compact?: boolean): string;
}

/**
 * The state of a contract, consisting primarily of the {@link data} accessible
 * directly to the contract, and the map of {@link ContractOperation}s that can
 * be called on it, the keys of which can be accessed with {@link operations},
 * and the individual operations can be read with {@link operation} and written
 * to with {@link setOperation}.
 */
export class ContractState {
  /**
   * Creates a blank contract state
   */
  constructor();
  /**
   * Return a list of the entry points currently registered on this contract
   */
  operations(): Array<string | Uint8Array>
  /**
   * Get the operation at a specific entry point name
   */
  operation(operation: string | Uint8Array): ContractOperation | undefined;
  /**
   * Set a specific entry point name to contain a given operation
   */
  setOperation(operation: string | Uint8Array, value: ContractOperation): void;
  /**
   * Runs a series of operations against the current state, and returns the
   * results
   */
  query(query: Op<null>[], cost_model: CostModel): GatherResult[];
  serialize(networkid: NetworkId): Uint8Array;
  static deserialize(raw: Uint8Array, networkid: NetworkId): ContractState;
  toString(compact?: boolean): string;
  /**
   * The current value of the primary state of the contract
   */
  data: StateValue;
  /**
   * The maintenance authority associated with this contract
   */
  maintenanceAuthority: ContractMaintenanceAuthority;
}

/**
 * Provides the information needed to fully process a transaction, including
 * information about the rest of the transaction, and the state of the chain at
 * the time of execution.
 */
export class QueryContext {
  /**
   * Construct a basic context from a contract's address and current state
   * value
   */
  constructor(state: StateValue, address: ContractAddress);
  /**
   * Register a given coin commitment as being accessible at a specific index,
   * for use when receiving coins in-contract, and needing to record their
   * index to later spend them
   */
  insertCommitment(comm: CoinCommitment, index: bigint): QueryContext;
  /**
   * Internal counterpart to {@link insertCommitment}; upgrades an encoded
   * {@link CoinInfo} to an encoded {@link QualifiedCoinInfo} using the
   * inserted commitments
   * @internal
   */
  qualify(coin: Value): Value | undefined;
  /**
   * Runs a transcript in verifying mode against the current query context,
   * outputting a new query context, with the {@link state} and {@link effects}
   * from after the execution.
   */
  runTranscript(transcript: Transcript<AlignedValue>, cost_model: CostModel): QueryContext;
  /**
   * Runs a sequence of operations in gather mode, returning the results of the
   * gather.
   */
  query(ops: Op<null>[], cost_model: CostModel, gas_limit?: bigint): QueryResults;
  /**
   * Finalizes a sequence of operations against their initial context,
   * resulting in a guaranteed and fallible {@link Transcript}, optimally
   * allocated, and heuristically covered for gas fees.
   *
   * @deprecated Please use the ledger's `partitionTranscripts` instead.
   */
  intoTranscript(program: Op<AlignedValue>[], cost_model: CostModel): [Transcript<AlignedValue> | undefined, Transcript<AlignedValue> | undefined];
  toString(compact?: boolean): string;
  /**
   * The address of the contract
   */
  readonly address: ContractAddress;
  /**
   * The block-level information accessible to the contract
   */
  block: BlockContext;
  /**
   * The commitment indices map accessible to the contract, primarily via
   * {@link qualify}
   */
  readonly comIndicies: Map<CoinCommitment, bigint>;
  /**
   * The effects that occurred during execution against this context, should
   * match those declared in a {@link Transcript}
   */
  effects: Effects;
  /**
   * The current contract state retained in the context
   */
  readonly state: StateValue;
}

/**
 * A cost model for calculating transaction fees
 */
export class CostModel {
  private constructor();
  /**
   * A cost model for use in non-critical contexts
   */
  static dummyCostModel(): CostModel;
  toString(compact?: boolean): string;
}

/**
 * The results of making a query against a specific state or context
 */
export class QueryResults {
  private constructor();
  toString(compact?: boolean): string;
  /**
   * The context state after executing the query. This can be used to execute
   * further queries
   */
  readonly context: QueryContext;
  /**
   * Any events/results that occurred during or from the query
   */
  readonly events: GatherResult[];
  /**
   * The measured cost of executing the query
   */
  readonly gasCost: bigint;
}

/**
 * Represents a fixed-depth Merkle tree storing hashed data, whose preimages
 * are unknown
 */
export class StateBoundedMerkleTree {
  /**
   * Create a blank tree with the given height
   */
  constructor(height: number);
  /**
   * Internal implementation of the merkle tree root primitive
   * @internal
   */
  root(): Value;
  /**
   * Internal implementation of the finding path primitive
   * @internal
   * @throws If the leaf is not in the tree
   */
  findPathForLeaf(leaf: AlignedValue): AlignedValue;
  /**
   * Internal implementation of the path construction primitive
   * @internal
   * @throws If the index is out-of-bounds for the tree
   */
  pathForLeaf(index: bigint, leaf: AlignedValue): AlignedValue;
  /**
   * Inserts a value into the Merkle tree, returning the updated tree
   * @throws If the index is out-of-bounds for the tree
   */
  update(index: bigint, leaf: AlignedValue): StateBoundedMerkleTree;
  /**
   * Erases all but necessary hashes between, and inclusive of, `start` and
   * `end` inidices @internal
   * @throws If the indices are out-of-bounds for the tree, or `end < start`
   */
  collapse(start: bigint, end: bigint): StateBoundedMerkleTree;
  toString(compact?: boolean): string;
  readonly height: number;
}

/**
 * Represents a key-value map, where keys are {@link AlignedValue}s, and values
 * are {@link StateValue}s.
 */
export class StateMap {
  constructor();
  keys(): AlignedValue[];
  get(key: AlignedValue): StateValue | undefined;
  insert(key: AlignedValue, value: StateValue): StateMap;
  remove(key: AlignedValue): StateMap;
  toString(compact?: boolean): string;
}

/**
 * Represents the core of a contract's state, and recursively represents each
 * of its components.
 *
 * There are different *classes* of state values:
 * - `null`
 * - Cells of {@link AlignedValue}s
 * - Maps from {@link AlignedValue}s to state values
 * - Bounded Merkle trees containing {@link AlignedValue} leaves
 * - Short (\<= 15 element) arrays of state values
 *
 * State values are *immutable*, any operations that mutate states will return
 * a new state instead.
 */
export class StateValue {
  private constructor();
  type(): "null" | "cell" | "map" | "array" | "boundedMerkleTree";
  static newNull(): StateValue;
  static newCell(value: AlignedValue): StateValue;
  static newMap(map: StateMap): StateValue;
  static newBoundedMerkleTree(tree: StateBoundedMerkleTree): StateValue;
  static newArray(): StateValue;
  arrayPush(value: StateValue): StateValue;
  asCell(): AlignedValue;
  asMap(): StateMap | undefined;
  asBoundedMerkleTree(): StateBoundedMerkleTree | undefined;
  asArray(): StateValue[] | undefined;
  logSize(): number;
  toString(compact?: boolean): string;
  /**
   * @internal
   */
  encode(): EncodedStateValue;
  /**
   * @internal
   */
  static decode(value: EncodedStateValue): StateValue;
}

/**
 * Represents the results of a VM call
 */
export class VmResults {
  private constructor();
  toString(compact?: boolean): string;
  /**
   * The events that got emitted by this VM invocation
   */
  readonly events: GatherResult[];
  /**
   * The computed gas cost of running this VM invocation
   */
  readonly gasCost: bigint;
  /**
   * The VM stack at the end of the VM invocation
   */
  readonly stack: VmStack;
}

/**
 * Represents the state of the VM's stack at a specific point. The stack is an
 * array of {@link StateValue}s, each of which is also annotated with whether
 * it is "strong" or "weak"; that is, whether it is permitted to be stored
 * on-chain or not.
 */
export class VmStack {
  constructor();
  push(value: StateValue, is_strong: boolean): void;
  removeLast(): void;
  length(): number;
  get(idx: number): StateValue | undefined;
  isStrong(idx: number): boolean | undefined;
  toString(compact?: boolean): string;
}
