'use strict';

var buffer = require('buffer');
var level = require('level');
var _ = require('lodash');
var superjson = require('superjson');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var superjson__namespace = /*#__PURE__*/_interopNamespaceDefault(superjson);

/**
 * The default name of the indexedDB database for Midnight.
 */
const MN_LDB_DEFAULT_DB_NAME = 'midnight-level-db';
/**
 * The default name of the private state store.
 */
const MN_LDB_DEFAULT_PRIS_STORE_NAME = 'private-states';
/**
 * The default name of the signing key store.
 */
const MN_LDB_DEFAULT_KEY_STORE_NAME = 'signing-keys';
/**
 * The default configuration for the level database.
 */
const DEFAULT_CONFIG = {
    /**
     * The name of the database.
     */
    midnightDbName: MN_LDB_DEFAULT_DB_NAME,
    /**
     * The name of the "level" on which to store private state.
     */
    privateStateStoreName: MN_LDB_DEFAULT_PRIS_STORE_NAME,
    /**
     * The name of the "level" on which to store signing keys.
     */
    signingKeyStoreName: MN_LDB_DEFAULT_KEY_STORE_NAME
};
superjson__namespace.registerCustom({
    isApplicable: (v) => v instanceof buffer.Buffer,
    serialize: (v) => v.toString('hex'),
    deserialize: (v) => buffer.Buffer.from(v, 'hex')
}, 'buffer');
const withSubLevel = async (dbName, levelName, thunk) => {
    const level$1 = new level.Level(dbName, {
        createIfMissing: true
    });
    const subLevel = level$1.sublevel(levelName, {
        valueEncoding: {
            encode: superjson__namespace.stringify,
            decode: superjson__namespace.parse,
            name: 'super-json-values'
        }
    });
    try {
        await level$1.open();
        await subLevel.open();
        return await thunk(subLevel);
    }
    finally {
        await subLevel.close();
        await level$1.close();
    }
};
const subLevelMaybeGet = (dbName, levelName, key) => {
    return withSubLevel(dbName, levelName, async (subLevel) => {
        const value = await subLevel.get(key);
        // We convert undefined values to null because we use undefined for contracts without private
        // state, and we want to be able to distinguish private states that are undefined but present
        // from private states that are not present at all.
        if (value === undefined) {
            return null;
        }
        return value;
    });
};
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Constructs an instance of {@link PrivateStateProvider} based on {@link Level} database.
 *
 * @param partialConfig Database configuration options.
 */
const levelPrivateStateProvider = (partialConfig = {}) => {
    const config = _.defaults(partialConfig, DEFAULT_CONFIG);
    return {
        get(privateStateId) {
            return subLevelMaybeGet(config.midnightDbName, config.privateStateStoreName, privateStateId);
        },
        remove(privateStateId) {
            return withSubLevel(config.midnightDbName, config.privateStateStoreName, (subLevel) => subLevel.del(privateStateId));
        },
        set(privateStateId, state) {
            return withSubLevel(config.midnightDbName, config.privateStateStoreName, (subLevel) => subLevel.put(privateStateId, state));
        },
        clear() {
            return withSubLevel(config.midnightDbName, config.privateStateStoreName, (subLevel) => subLevel.clear());
        },
        getSigningKey(address) {
            return subLevelMaybeGet(config.midnightDbName, config.signingKeyStoreName, address);
        },
        removeSigningKey(address) {
            return withSubLevel(config.midnightDbName, config.signingKeyStoreName, (subLevel) => subLevel.del(address));
        },
        setSigningKey(address, signingKey) {
            return withSubLevel(config.midnightDbName, config.signingKeyStoreName, (subLevel) => subLevel.put(address, signingKey));
        },
        clearSigningKeys() {
            return withSubLevel(config.midnightDbName, config.signingKeyStoreName, (subLevel) => subLevel.clear());
        }
    };
};

exports.DEFAULT_CONFIG = DEFAULT_CONFIG;
exports.levelPrivateStateProvider = levelPrivateStateProvider;
//# sourceMappingURL=index.cjs.map
